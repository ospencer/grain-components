// Generated by wit-bindgen. DO NOT EDIT!

module Imports

from "runtime/dataStructures" include DataStructures
from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/wasmi64" include WasmI64
from "runtime/unsafe/wasmf32" include WasmF32
from "runtime/unsafe/wasmf64" include WasmF64
from "runtime/unsafe/memory" include Memory
from "int32" include Int32
from "int64" include Int64
from "char" include Char
from "list" include List

@unsafe
let _RET_AREA = Memory.malloc(56n)

provide record Resource<a> {
  mut handle: Int32,
  rep: a
}



provide module Random {

  @externalName("get-random-bytes")
  foreign wasm wit_bindgen_getRandomBytes: (WasmI64, WasmI32) -> Void from "wasi:random/random@0.2.0"

  /// Return `len` cryptographically-secure random or pseudo-random bytes.
  /// 
  /// This function must produce data at least as cryptographically secure and
  /// fast as an adequately seeded cryptographically-secure pseudo-random
  /// number generator (CSPRNG). It must not block, from the perspective of
  /// the calling program, under any circumstances, including on the first
  /// request and on requests for numbers of bytes. The returned data must
  /// always be unpredictable.
  /// 
  /// This function must always return fresh data. Deterministic environments
  /// must omit this function, rather than implementing it with deterministic
  /// data.
  @unsafe
  provide let getRandomBytes: (Uint64) -> Bytes = (len) => {
    wit_bindgen_getRandomBytes(WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
    let len_list_canon_lift = WasmI32.load(_RET_AREA, 4n)
    let bytes_list_canon_lift = DataStructures.allocateBytes(len_list_canon_lift)
    Memory.copy(WasmI32.(+)(bytes_list_canon_lift, 8n), WasmI32.load(_RET_AREA, 0n), len_list_canon_lift)
    let bytes_list_canon_lift = WasmI32.toGrain(bytes_list_canon_lift): Bytes
    bytes_list_canon_lift
  }


  @externalName("get-random-u64")
  foreign wasm wit_bindgen_getRandomU64: () -> WasmI64 from "wasi:random/random@0.2.0"

  /// Return a cryptographically-secure random or pseudo-random `u64` value.
  /// 
  /// This function returns the same type of data as `get-random-bytes`,
  /// represented as a `u64`.
  @unsafe
  provide let getRandomU64: () -> Uint64 = () => {
    let ret = wit_bindgen_getRandomU64()
    WasmI32.toGrain(DataStructures.newUint64(ret)): Uint64
  }

}

provide record Error {
  handle: Int32
}


provide module Error {

  provide module Error {
    @externalName("[method]error.to-debug-string")
    foreign wasm wit_bindgen_methodError_toDebugString: (WasmI32, WasmI32) -> Void from "wasi:io/error@0.2.0"

    /// Returns a string that is suitable to assist humans in debugging
    /// this error.
    /// 
    /// WARNING: The returned string should not be consumed mechanically!
    /// It may change across platforms, hosts, or other implementation
    /// details. Parsing this string is a major platform-compatibility
    /// hazard.
    @unsafe
    provide let toDebugString: (Error) -> String = (self) => {
      wit_bindgen_methodError_toDebugString(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      let len_string_lift = WasmI32.load(_RET_AREA, 4n)
      let str_string_lift = DataStructures.allocateString(len_string_lift)
      Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 0n), len_string_lift)
      let str_string_lift = WasmI32.toGrain(str_string_lift): String
      str_string_lift
    }

  }
}

provide record Pollable {
  handle: Int32
}


provide module Poll {

  @externalName("poll")
  foreign wasm wit_bindgen_poll: (WasmI32, WasmI32, WasmI32) -> Void from "wasi:io/poll@0.2.0"

  /// Poll for completion on a set of pollables.
  /// 
  /// This function takes a list of pollables, which identify I/O sources of
  /// interest, and waits until one or more of the events is ready for I/O.
  /// 
  /// The result `list<u32>` contains one or more indices of handles in the
  /// argument list that is ready for I/O.
  /// 
  /// If the list contains more elements than can be indexed with a `u32`
  /// value, this function traps.
  /// 
  /// A timeout can be implemented by adding a pollable from the
  /// wasi-clocks API to the list.
  /// 
  /// This function does not return a `result`; polling in itself does not
  /// do any I/O so it doesn't fail. If any of the I/O sources identified by
  /// the pollables has an error, it is indicated by marking the source as
  /// being reaedy for I/O.
  @unsafe
  provide let poll: (List<Pollable>) -> List<Uint32> = (in) => {
    let vec_list_lower = in
    let len_list_lower = WasmI32.(>>>)(WasmI32.fromGrain(List.length(vec_list_lower)), 1n)
    let result_list_lower = Memory.malloc(WasmI32.(*)(len_list_lower, 4n))
    let mut list = vec_list_lower
    let mut i = 0n
    while (true) {
      match (list) {
        [] => {
          break
        },
        [e, ...rest] => {
          list = rest
          let base = WasmI32.(+)(result_list_lower, WasmI32.(*)(i, 4n))
          i = WasmI32.(+)(i, 1n)
          WasmI32.store(base, WasmI32.load(WasmI32.fromGrain(e.handle), 4n), 0n)
        }
      }
    }
    wit_bindgen_poll(result_list_lower, len_list_lower, _RET_AREA)
    let base_list_lift = WasmI32.load(_RET_AREA, 0n)
    let len_list_lift = WasmI32.load(_RET_AREA, 4n)
    let mut result_list_lift = []
    Memory.incRef(WasmI32.fromGrain(result_list_lift))
    for (let mut i = WasmI32.(-)(len_list_lift, 1n); WasmI32.gtU(i, 0n); i = WasmI32.(-)(i, 1n)) {
      let base = WasmI32.(+)(base_list_lift, WasmI32.(*)(i, 4n))
      result_list_lift = [WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(base, 0n))): Uint32, ...result_list_lift]
    }
    result_list_lift
  }


  provide module Pollable {
    @externalName("[method]pollable.ready")
    foreign wasm wit_bindgen_methodPollable_ready: (WasmI32) -> WasmI32 from "wasi:io/poll@0.2.0"

    /// Return the readiness of a pollable. This function never blocks.
    /// 
    /// Returns `true` when the pollable is ready, and `false` otherwise.
    @unsafe
    provide let ready: (Pollable) -> Bool = (self) => {
      let ret = wit_bindgen_methodPollable_ready(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(ret, 31n), WasmI32.fromGrain(false))): Bool
    }


    @externalName("[method]pollable.block")
    foreign wasm wit_bindgen_methodPollable_block: (WasmI32) -> Void from "wasi:io/poll@0.2.0"

    /// `block` returns immediately if the pollable is ready, and otherwise
    /// blocks until ready.
    /// 
    /// This function is equivalent to calling `poll.poll` on a list
    /// containing only this pollable.
    @unsafe
    provide let block: (Pollable) -> Void = (self) => {
      wit_bindgen_methodPollable_block(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      void
    }

  }
}

provide enum StreamError {
  LastOperationFailed(Error),
  Closed,
}
provide record InputStream {
  handle: Int32
}
provide record OutputStream {
  handle: Int32
}


provide module Streams {

  provide module InputStream {
    @externalName("[method]input-stream.read")
    foreign wasm wit_bindgen_methodInputStream_read: (WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Perform a non-blocking read from the stream.
    /// 
    /// When the source of a `read` is binary data, the bytes from the source
    /// are returned verbatim. When the source of a `read` is known to the
    /// implementation to be text, bytes containing the UTF-8 encoding of the
    /// text are returned.
    /// 
    /// This function returns a list of bytes containing the read data,
    /// when successful. The returned list will contain up to `len` bytes;
    /// it may return fewer than requested, but not more. The list is
    /// empty when no bytes are available for reading at this time. The
    /// pollable given by `subscribe` will be ready when more bytes are
    /// available.
    /// 
    /// This function fails with a `stream-error` when the operation
    /// encounters an error, giving `last-operation-failed`, or when the
    /// stream is closed, giving `closed`.
    /// 
    /// When the caller gives a `len` of 0, it represents a request to
    /// read 0 bytes. If the stream is still open, this call should
    /// succeed and return an empty list, or otherwise fail with `closed`.
    /// 
    /// The `len` parameter is a `u64`, which could represent a list of u8 which
    /// is not possible to allocate in wasm32, or not desirable to allocate as
    /// as a return value by the callee. The callee may return a list of bytes
    /// less than `len` in size while more bytes are available for reading.
    @unsafe
    provide let read: (InputStream, Uint64) -> Result<Bytes, StreamError> = (self, len) => {
      wit_bindgen_methodInputStream_read(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let len_list_canon_lift = WasmI32.load(_RET_AREA, 8n)
          let bytes_list_canon_lift = DataStructures.allocateBytes(len_list_canon_lift)
          Memory.copy(WasmI32.(+)(bytes_list_canon_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_list_canon_lift)
          let bytes_list_canon_lift = WasmI32.toGrain(bytes_list_canon_lift): Bytes

          Ok(bytes_list_canon_lift)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]input-stream.blocking-read")
    foreign wasm wit_bindgen_methodInputStream_blockingRead: (WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Read bytes from a stream, after blocking until at least one byte can
    /// be read. Except for blocking, behavior is identical to `read`.
    @unsafe
    provide let blockingRead: (InputStream, Uint64) -> Result<Bytes, StreamError> = (self, len) => {
      wit_bindgen_methodInputStream_blockingRead(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let len_list_canon_lift = WasmI32.load(_RET_AREA, 8n)
          let bytes_list_canon_lift = DataStructures.allocateBytes(len_list_canon_lift)
          Memory.copy(WasmI32.(+)(bytes_list_canon_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_list_canon_lift)
          let bytes_list_canon_lift = WasmI32.toGrain(bytes_list_canon_lift): Bytes

          Ok(bytes_list_canon_lift)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]input-stream.skip")
    foreign wasm wit_bindgen_methodInputStream_skip: (WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Skip bytes from a stream. Returns number of bytes skipped.
    /// 
    /// Behaves identical to `read`, except instead of returning a list
    /// of bytes, returns the number of bytes consumed from the stream.
    @unsafe
    provide let skip: (InputStream, Uint64) -> Result<Uint64, StreamError> = (self, len) => {
      wit_bindgen_methodInputStream_skip(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 12n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]input-stream.blocking-skip")
    foreign wasm wit_bindgen_methodInputStream_blockingSkip: (WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Skip bytes from a stream, after blocking until at least one byte
    /// can be skipped. Except for blocking behavior, identical to `skip`.
    @unsafe
    provide let blockingSkip: (InputStream, Uint64) -> Result<Uint64, StreamError> = (self, len) => {
      wit_bindgen_methodInputStream_blockingSkip(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 12n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]input-stream.subscribe")
    foreign wasm wit_bindgen_methodInputStream_subscribe: (WasmI32) -> WasmI32 from "wasi:io/streams@0.2.0"

    /// Create a `pollable` which will resolve once either the specified stream
    /// has bytes available to read or the other end of the stream has been
    /// closed.
    /// The created `pollable` is a child resource of the `input-stream`.
    /// Implementations may trap if the `input-stream` is dropped before
    /// all derived `pollable`s created with this function are dropped.
    @unsafe
    provide let subscribe: (InputStream) -> Pollable = (self) => {
      let ret = wit_bindgen_methodInputStream_subscribe(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Pollable
      handle_lift
    }

  }

  provide module OutputStream {
    @externalName("[method]output-stream.check-write")
    foreign wasm wit_bindgen_methodOutputStream_checkWrite: (WasmI32, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Check readiness for writing. This function never blocks.
    /// 
    /// Returns the number of bytes permitted for the next call to `write`,
    /// or an error. Calling `write` with more bytes than this function has
    /// permitted will trap.
    /// 
    /// When this function returns 0 bytes, the `subscribe` pollable will
    /// become ready when this function will report at least 1 byte, or an
    /// error.
    @unsafe
    provide let checkWrite: (OutputStream) -> Result<Uint64, StreamError> = (self) => {
      wit_bindgen_methodOutputStream_checkWrite(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 12n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.write")
    foreign wasm wit_bindgen_methodOutputStream_write: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Perform a write. This function never blocks.
    /// 
    /// When the destination of a `write` is binary data, the bytes from
    /// `contents` are written verbatim. When the destination of a `write` is
    /// known to the implementation to be text, the bytes of `contents` are
    /// transcoded from UTF-8 into the encoding of the destination and then
    /// written.
    /// 
    /// Precondition: check-write gave permit of Ok(n) and contents has a
    /// length of less than or equal to n. Otherwise, this function will trap.
    /// 
    /// returns Err(closed) without writing if the stream has closed since
    /// the last call to check-write provided a permit.
    @unsafe
    provide let write: (OutputStream, Bytes) -> Result<Void, StreamError> = (self, contents) => {
      let vec_list_canon_lower = contents
      let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
      let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
      wit_bindgen_methodOutputStream_write(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), ptr_list_canon_lower, len_list_canon_lower, _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.blocking-write-and-flush")
    foreign wasm wit_bindgen_methodOutputStream_blockingWriteAndFlush: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Perform a write of up to 4096 bytes, and then flush the stream. Block
    /// until all of these operations are complete, or an error occurs.
    /// 
    /// This is a convenience wrapper around the use of `check-write`,
    /// `subscribe`, `write`, and `flush`, and is implemented with the
    /// following pseudo-code:
    /// 
    /// ```text
    /// let pollable = this.subscribe();
    /// while !contents.is_empty() {
    /// // Wait for the stream to become writable
    /// pollable.block();
    /// let Ok(n) = this.check-write(); // eliding error handling
    /// let len = min(n, contents.len());
    /// let (chunk, rest) = contents.split_at(len);
    /// this.write(chunk  );            // eliding error handling
    /// contents = rest;
    /// }
    /// this.flush();
    /// // Wait for completion of `flush`
    /// pollable.block();
    /// // Check for any errors that arose during `flush`
    /// let _ = this.check-write();         // eliding error handling
    /// ```
    @unsafe
    provide let blockingWriteAndFlush: (OutputStream, Bytes) -> Result<Void, StreamError> = (self, contents) => {
      let vec_list_canon_lower = contents
      let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
      let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
      wit_bindgen_methodOutputStream_blockingWriteAndFlush(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), ptr_list_canon_lower, len_list_canon_lower, _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.flush")
    foreign wasm wit_bindgen_methodOutputStream_flush: (WasmI32, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Request to flush buffered output. This function never blocks.
    /// 
    /// This tells the output-stream that the caller intends any buffered
    /// output to be flushed. the output which is expected to be flushed
    /// is all that has been passed to `write` prior to this call.
    /// 
    /// Upon calling this function, the `output-stream` will not accept any
    /// writes (`check-write` will return `ok(0)`) until the flush has
    /// completed. The `subscribe` pollable will become ready when the
    /// flush has completed and the stream can accept more writes.
    @unsafe
    provide let flush: (OutputStream) -> Result<Void, StreamError> = (self) => {
      wit_bindgen_methodOutputStream_flush(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.blocking-flush")
    foreign wasm wit_bindgen_methodOutputStream_blockingFlush: (WasmI32, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Request to flush buffered output, and block until flush completes
    /// and stream is ready for writing again.
    @unsafe
    provide let blockingFlush: (OutputStream) -> Result<Void, StreamError> = (self) => {
      wit_bindgen_methodOutputStream_blockingFlush(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.subscribe")
    foreign wasm wit_bindgen_methodOutputStream_subscribe: (WasmI32) -> WasmI32 from "wasi:io/streams@0.2.0"

    /// Create a `pollable` which will resolve once the output-stream
    /// is ready for more writing, or an error has occured. When this
    /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
    /// error.
    /// 
    /// If the stream is closed, this pollable is always ready immediately.
    /// 
    /// The created `pollable` is a child resource of the `output-stream`.
    /// Implementations may trap if the `output-stream` is dropped before
    /// all derived `pollable`s created with this function are dropped.
    @unsafe
    provide let subscribe: (OutputStream) -> Pollable = (self) => {
      let ret = wit_bindgen_methodOutputStream_subscribe(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Pollable
      handle_lift
    }


    @externalName("[method]output-stream.write-zeroes")
    foreign wasm wit_bindgen_methodOutputStream_writeZeroes: (WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Write zeroes to a stream.
    /// 
    /// This should be used precisely like `write` with the exact same
    /// preconditions (must use check-write first), but instead of
    /// passing a list of bytes, you simply pass the number of zero-bytes
    /// that should be written.
    @unsafe
    provide let writeZeroes: (OutputStream, Uint64) -> Result<Void, StreamError> = (self, len) => {
      wit_bindgen_methodOutputStream_writeZeroes(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.blocking-write-zeroes-and-flush")
    foreign wasm wit_bindgen_methodOutputStream_blockingWriteZeroesAndFlush: (WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Perform a write of up to 4096 zeroes, and then flush the stream.
    /// Block until all of these operations are complete, or an error
    /// occurs.
    /// 
    /// This is a convenience wrapper around the use of `check-write`,
    /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
    /// the following pseudo-code:
    /// 
    /// ```text
    /// let pollable = this.subscribe();
    /// while num_zeroes != 0 {
    /// // Wait for the stream to become writable
    /// pollable.block();
    /// let Ok(n) = this.check-write(); // eliding error handling
    /// let len = min(n, num_zeroes);
    /// this.write-zeroes(len);         // eliding error handling
    /// num_zeroes -= len;
    /// }
    /// this.flush();
    /// // Wait for completion of `flush`
    /// pollable.block();
    /// // Check for any errors that arose during `flush`
    /// let _ = this.check-write();         // eliding error handling
    /// ```
    @unsafe
    provide let blockingWriteZeroesAndFlush: (OutputStream, Uint64) -> Result<Void, StreamError> = (self, len) => {
      wit_bindgen_methodOutputStream_blockingWriteZeroesAndFlush(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.splice")
    foreign wasm wit_bindgen_methodOutputStream_splice: (WasmI32, WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Read from one stream and write to another.
    /// 
    /// The behavior of splice is equivelant to:
    /// 1. calling `check-write` on the `output-stream`
    /// 2. calling `read` on the `input-stream` with the smaller of the
    /// `check-write` permitted length and the `len` provided to `splice`
    /// 3. calling `write` on the `output-stream` with that read data.
    /// 
    /// Any error reported by the call to `check-write`, `read`, or
    /// `write` ends the splice and reports that error.
    /// 
    /// This function returns the number of bytes transferred; it may be less
    /// than `len`.
    @unsafe
    provide let splice: (OutputStream, InputStream, Uint64) -> Result<Uint64, StreamError> = (self, src, len) => {
      wit_bindgen_methodOutputStream_splice(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI32.load(WasmI32.fromGrain(src.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 12n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]output-stream.blocking-splice")
    foreign wasm wit_bindgen_methodOutputStream_blockingSplice: (WasmI32, WasmI32, WasmI64, WasmI32) -> Void from "wasi:io/streams@0.2.0"

    /// Read from one stream and write to another, with blocking.
    /// 
    /// This is similar to `splice`, except that it blocks until the
    /// `output-stream` is ready for writing, and the `input-stream`
    /// is ready for reading, before performing the `splice`.
    @unsafe
    provide let blockingSplice: (OutputStream, InputStream, Uint64) -> Result<Uint64, StreamError> = (self, src, len) => {
      wit_bindgen_methodOutputStream_blockingSplice(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI32.load(WasmI32.fromGrain(src.handle), 4n), WasmI64.load(WasmI32.fromGrain(len), 8n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 12n))),}: Error
              LastOperationFailed(handle_lift)
            },
            _ => {
              Closed
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }
}



provide module Stdout {

  @externalName("get-stdout")
  foreign wasm wit_bindgen_getStdout: () -> WasmI32 from "wasi:cli/stdout@0.2.0"

  @unsafe
  provide let getStdout: () -> OutputStream = () => {
    let ret = wit_bindgen_getStdout()
    let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: OutputStream
    handle_lift
  }

}



provide module Stderr {

  @externalName("get-stderr")
  foreign wasm wit_bindgen_getStderr: () -> WasmI32 from "wasi:cli/stderr@0.2.0"

  @unsafe
  provide let getStderr: () -> OutputStream = () => {
    let ret = wit_bindgen_getStderr()
    let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: OutputStream
    handle_lift
  }

}



provide module Stdin {

  @externalName("get-stdin")
  foreign wasm wit_bindgen_getStdin: () -> WasmI32 from "wasi:cli/stdin@0.2.0"

  @unsafe
  provide let getStdin: () -> InputStream = () => {
    let ret = wit_bindgen_getStdin()
    let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: InputStream
    handle_lift
  }

}

provide type Instant = Uint64
provide type Duration = Uint64


provide module MonotonicClock {

  @externalName("now")
  foreign wasm wit_bindgen_now: () -> WasmI64 from "wasi:clocks/monotonic-clock@0.2.0"

  /// Read the current value of the clock.
  /// 
  /// The clock is monotonic, therefore calling this function repeatedly will
  /// produce a sequence of non-decreasing values.
  @unsafe
  provide let now: () -> Instant = () => {
    let ret = wit_bindgen_now()
    WasmI32.toGrain(DataStructures.newUint64(ret)): Uint64
  }


  @externalName("resolution")
  foreign wasm wit_bindgen_resolution: () -> WasmI64 from "wasi:clocks/monotonic-clock@0.2.0"

  /// Query the resolution of the clock. Returns the duration of time
  /// corresponding to a clock tick.
  @unsafe
  provide let resolution: () -> Duration = () => {
    let ret = wit_bindgen_resolution()
    WasmI32.toGrain(DataStructures.newUint64(ret)): Uint64
  }


  @externalName("subscribe-instant")
  foreign wasm wit_bindgen_subscribeInstant: (WasmI64) -> WasmI32 from "wasi:clocks/monotonic-clock@0.2.0"

  /// Create a `pollable` which will resolve once the specified instant
  /// occured.
  @unsafe
  provide let subscribeInstant: (Instant) -> Pollable = (when_) => {
    let ret = wit_bindgen_subscribeInstant(WasmI64.load(WasmI32.fromGrain(when_), 8n))
    let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Pollable
    handle_lift
  }


  @externalName("subscribe-duration")
  foreign wasm wit_bindgen_subscribeDuration: (WasmI64) -> WasmI32 from "wasi:clocks/monotonic-clock@0.2.0"

  /// Create a `pollable` which will resolve once the given duration has
  /// elapsed, starting at the time at which this function was called.
  /// occured.
  @unsafe
  provide let subscribeDuration: (Duration) -> Pollable = (when_) => {
    let ret = wit_bindgen_subscribeDuration(WasmI64.load(WasmI32.fromGrain(when_), 8n))
    let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Pollable
    handle_lift
  }

}

provide type IoError = Error
provide enum Method {
  Get,
  Head,
  Post,
  Put,
  Delete,
  Connect,
  Options,
  Trace,
  Patch,
  Other(String),
}
provide enum Scheme {
  Http,
  Https,
  Other(String),
}
provide record DnsErrorPayload {
  rcode: Option<String>,
  infoCode: Option<Uint16>,
}
provide record TlsAlertReceivedPayload {
  alertId: Option<Uint8>,
  alertMessage: Option<String>,
}
provide record FieldSizePayload {
  fieldName: Option<String>,
  fieldSize: Option<Uint32>,
}
provide enum ErrorCode {
  DnsTimeout,
  DnsError(DnsErrorPayload),
  DestinationNotFound,
  DestinationUnavailable,
  DestinationIpProhibited,
  DestinationIpUnroutable,
  ConnectionRefused,
  ConnectionTerminated,
  ConnectionTimeout,
  ConnectionReadTimeout,
  ConnectionWriteTimeout,
  ConnectionLimitReached,
  TlsProtocolError,
  TlsCertificateError,
  TlsAlertReceived(TlsAlertReceivedPayload),
  HttpRequestDenied,
  HttpRequestLengthRequired,
  HttpRequestBodySize(Option<Uint64>),
  HttpRequestMethodInvalid,
  HttpRequestUriInvalid,
  HttpRequestUriTooLong,
  HttpRequestHeaderSectionSize(Option<Uint32>),
  HttpRequestHeaderSize(Option<FieldSizePayload>),
  HttpRequestTrailerSectionSize(Option<Uint32>),
  HttpRequestTrailerSize(FieldSizePayload),
  HttpResponseIncomplete,
  HttpResponseHeaderSectionSize(Option<Uint32>),
  HttpResponseHeaderSize(FieldSizePayload),
  HttpResponseBodySize(Option<Uint64>),
  HttpResponseTrailerSectionSize(Option<Uint32>),
  HttpResponseTrailerSize(FieldSizePayload),
  HttpResponseTransferCoding(Option<String>),
  HttpResponseContentCoding(Option<String>),
  HttpResponseTimeout,
  HttpUpgradeFailed,
  HttpProtocolError,
  LoopDetected,
  ConfigurationError,
  InternalError(Option<String>),
}
provide enum HeaderError {
  InvalidSyntax,
  Forbidden,
  Immutable,
}
provide type FieldKey = String
provide type FieldValue = Bytes
provide record Fields {
  handle: Int32
}
provide type Headers = Fields
provide type Trailers = Fields
provide record IncomingRequest {
  handle: Int32
}
provide record OutgoingRequest {
  handle: Int32
}
provide record RequestOptions {
  handle: Int32
}
provide record ResponseOutparam {
  handle: Int32
}
provide type StatusCode = Uint16
provide record IncomingResponse {
  handle: Int32
}
provide record IncomingBody {
  handle: Int32
}
provide record FutureTrailers {
  handle: Int32
}
provide record OutgoingResponse {
  handle: Int32
}
provide record OutgoingBody {
  handle: Int32
}
provide record FutureIncomingResponse {
  handle: Int32
}


provide module Types {

  @externalName("http-error-code")
  foreign wasm wit_bindgen_httpErrorCode: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

  /// Attempts to extract a http-related `error` from the wasi:io `error`
  /// provided.
  /// 
  /// Stream operations which return
  /// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
  /// type `wasi:io/error/error` with more information about the operation
  /// that failed. This payload can be passed through to this function to see
  /// if there's http-related information about the error to return.
  /// 
  /// Note that this function is fallible because not all io-errors are
  /// http-related errors.
  @unsafe
  provide let httpErrorCode: (IoError) -> Option<ErrorCode> = (err) => {
    wit_bindgen_httpErrorCode(WasmI32.load(WasmI32.fromGrain(err.handle), 4n), _RET_AREA)
    match (WasmI32.load8U(_RET_AREA, 0n)) {
      0n => None,
      1n => {
        
        Some(match (WasmI32.load8U(_RET_AREA, 8n)) {
          0n => {
            DnsTimeout
          },
          1n => {
            DnsError({ rcode: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift = DataStructures.allocateString(len_string_lift)
                Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift)
                let str_string_lift = WasmI32.toGrain(str_string_lift): String

                Some(str_string_lift)
              },
              _ => fail "invalid enum discriminant",
            }, infoCode: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load16U(_RET_AREA, 30n), 8n), WasmI32.fromGrain(0uS))): Uint16)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          2n => {
            DestinationNotFound
          },
          3n => {
            DestinationUnavailable
          },
          4n => {
            DestinationIpProhibited
          },
          5n => {
            DestinationIpUnroutable
          },
          6n => {
            ConnectionRefused
          },
          7n => {
            ConnectionTerminated
          },
          8n => {
            ConnectionTimeout
          },
          9n => {
            ConnectionReadTimeout
          },
          10n => {
            ConnectionWriteTimeout
          },
          11n => {
            ConnectionLimitReached
          },
          12n => {
            TlsProtocolError
          },
          13n => {
            TlsCertificateError
          },
          14n => {
            TlsAlertReceived({ alertId: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load8U(_RET_AREA, 17n), 8n), WasmI32.fromGrain(0us))): Uint8)
              },
              _ => fail "invalid enum discriminant",
            }, alertMessage: match (WasmI32.load8U(_RET_AREA, 20n)) {
              0n => None,
              1n => {
                let len_string_lift0 = WasmI32.load(_RET_AREA, 28n)
                let str_string_lift0 = DataStructures.allocateString(len_string_lift0)
                Memory.copy(WasmI32.(+)(str_string_lift0, 8n), WasmI32.load(_RET_AREA, 24n), len_string_lift0)
                let str_string_lift0 = WasmI32.toGrain(str_string_lift0): String

                Some(str_string_lift0)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          15n => {
            HttpRequestDenied
          },
          16n => {
            HttpRequestLengthRequired
          },
          17n => {
            HttpRequestBodySize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 24n))): Uint64)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          18n => {
            HttpRequestMethodInvalid
          },
          19n => {
            HttpRequestUriInvalid
          },
          20n => {
            HttpRequestUriTooLong
          },
          21n => {
            HttpRequestHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          22n => {
            HttpRequestHeaderSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some({ fieldName: match (WasmI32.load8U(_RET_AREA, 20n)) {
                  0n => None,
                  1n => {
                    let len_string_lift1 = WasmI32.load(_RET_AREA, 28n)
                    let str_string_lift1 = DataStructures.allocateString(len_string_lift1)
                    Memory.copy(WasmI32.(+)(str_string_lift1, 8n), WasmI32.load(_RET_AREA, 24n), len_string_lift1)
                    let str_string_lift1 = WasmI32.toGrain(str_string_lift1): String

                    Some(str_string_lift1)
                  },
                  _ => fail "invalid enum discriminant",
                }, fieldSize: match (WasmI32.load8U(_RET_AREA, 32n)) {
                  0n => None,
                  1n => {
                    
                    Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                  },
                  _ => fail "invalid enum discriminant",
                } })
              },
              _ => fail "invalid enum discriminant",
            })
          },
          23n => {
            HttpRequestTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          24n => {
            HttpRequestTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift2 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift2 = DataStructures.allocateString(len_string_lift2)
                Memory.copy(WasmI32.(+)(str_string_lift2, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift2)
                let str_string_lift2 = WasmI32.toGrain(str_string_lift2): String

                Some(str_string_lift2)
              },
              _ => fail "invalid enum discriminant",
            }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          25n => {
            HttpResponseIncomplete
          },
          26n => {
            HttpResponseHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          27n => {
            HttpResponseHeaderSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift3 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift3 = DataStructures.allocateString(len_string_lift3)
                Memory.copy(WasmI32.(+)(str_string_lift3, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift3)
                let str_string_lift3 = WasmI32.toGrain(str_string_lift3): String

                Some(str_string_lift3)
              },
              _ => fail "invalid enum discriminant",
            }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          28n => {
            HttpResponseBodySize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 24n))): Uint64)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          29n => {
            HttpResponseTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          30n => {
            HttpResponseTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift4 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift4 = DataStructures.allocateString(len_string_lift4)
                Memory.copy(WasmI32.(+)(str_string_lift4, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift4)
                let str_string_lift4 = WasmI32.toGrain(str_string_lift4): String

                Some(str_string_lift4)
              },
              _ => fail "invalid enum discriminant",
            }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          31n => {
            HttpResponseTransferCoding(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift5 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift5 = DataStructures.allocateString(len_string_lift5)
                Memory.copy(WasmI32.(+)(str_string_lift5, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift5)
                let str_string_lift5 = WasmI32.toGrain(str_string_lift5): String

                Some(str_string_lift5)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          32n => {
            HttpResponseContentCoding(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift6 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift6 = DataStructures.allocateString(len_string_lift6)
                Memory.copy(WasmI32.(+)(str_string_lift6, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift6)
                let str_string_lift6 = WasmI32.toGrain(str_string_lift6): String

                Some(str_string_lift6)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          33n => {
            HttpResponseTimeout
          },
          34n => {
            HttpUpgradeFailed
          },
          35n => {
            HttpProtocolError
          },
          36n => {
            LoopDetected
          },
          37n => {
            ConfigurationError
          },
          _ => {
            InternalError(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift7 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift7 = DataStructures.allocateString(len_string_lift7)
                Memory.copy(WasmI32.(+)(str_string_lift7, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift7)
                let str_string_lift7 = WasmI32.toGrain(str_string_lift7): String

                Some(str_string_lift7)
              },
              _ => fail "invalid enum discriminant",
            })
          },
        })
      },
      _ => fail "invalid enum discriminant",
    }
  }


  provide module Fields {
    @externalName("[constructor]fields")
    foreign wasm wit_bindgen_constructorFields: () -> WasmI32 from "wasi:http/types@0.2.0"

    /// Construct an empty HTTP Fields.
    /// 
    /// The resulting `fields` is mutable.
    @unsafe
    provide let constructor: () -> Fields = () => {
      let ret = wit_bindgen_constructorFields()
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Fields
      handle_lift
    }


    @externalName("[static]fields.from-list")
    foreign wasm wit_bindgen_staticFields_fromList: (WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Construct an HTTP Fields.
    /// 
    /// The resulting `fields` is mutable.
    /// 
    /// The list represents each key-value pair in the Fields. Keys
    /// which have multiple values are represented by multiple entries in this
    /// list with the same key.
    /// 
    /// The tuple is a pair of the field key, represented as a string, and
    /// Value, represented as a list of bytes.
    /// 
    /// An error result will be returned if any `field-key` or `field-value` is
    /// syntactically invalid, or if a field is forbidden.
    @unsafe
    provide let fromList: (List<(FieldKey, FieldValue)>) -> Result<Fields, HeaderError> = (entries) => {
      let vec_list_lower = entries
      let len_list_lower = WasmI32.(>>>)(WasmI32.fromGrain(List.length(vec_list_lower)), 1n)
      let result_list_lower = Memory.malloc(WasmI32.(*)(len_list_lower, 16n))
      let mut list = vec_list_lower
      let mut i = 0n
      while (true) {
        match (list) {
          [] => {
            break
          },
          [e, ...rest] => {
            list = rest
            let base = WasmI32.(+)(result_list_lower, WasmI32.(*)(i, 16n))
            i = WasmI32.(+)(i, 1n)
            let (ttuple_0, ttuple_1) = e
            let vec_list_canon_lower = ttuple_0
            let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
            let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
            WasmI32.store(base, len_list_canon_lower, 4n)
            WasmI32.store(base, ptr_list_canon_lower, 0n)
            let vec_list_canon_lower0 = ttuple_1
            let ptr_list_canon_lower0 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower0), 8n)
            let len_list_canon_lower0 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower0), 4n)
            WasmI32.store(base, len_list_canon_lower0, 12n)
            WasmI32.store(base, ptr_list_canon_lower0, 8n)
          }
        }
      }
      wit_bindgen_staticFields_fromList(result_list_lower, len_list_lower, _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: Fields

          Ok(handle_lift)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              InvalidSyntax
            },
            1n => {
              Forbidden
            },
            _ => {
              Immutable
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]fields.get")
    foreign wasm wit_bindgen_methodFields_get: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Get all of the values corresponding to a key. If the key is not present
    /// in this `fields` or is syntactically invalid, an empty list is returned.
    /// However, if the key is present but empty, this is represented by a list
    /// with one or more empty field-values present.
    @unsafe
    provide let get: (Fields, FieldKey) -> List<FieldValue> = (self, name) => {
      let vec_list_canon_lower = name
      let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
      let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
      wit_bindgen_methodFields_get(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), ptr_list_canon_lower, len_list_canon_lower, _RET_AREA)
      let base_list_lift = WasmI32.load(_RET_AREA, 0n)
      let len_list_lift = WasmI32.load(_RET_AREA, 4n)
      let mut result_list_lift = []
      Memory.incRef(WasmI32.fromGrain(result_list_lift))
      for (let mut i = WasmI32.(-)(len_list_lift, 1n); WasmI32.gtU(i, 0n); i = WasmI32.(-)(i, 1n)) {
        let base = WasmI32.(+)(base_list_lift, WasmI32.(*)(i, 8n))
        let len_list_canon_lift = WasmI32.load(base, 4n)
        let bytes_list_canon_lift = DataStructures.allocateBytes(len_list_canon_lift)
        Memory.copy(WasmI32.(+)(bytes_list_canon_lift, 8n), WasmI32.load(base, 0n), len_list_canon_lift)
        let bytes_list_canon_lift = WasmI32.toGrain(bytes_list_canon_lift): Bytes
        result_list_lift = [bytes_list_canon_lift, ...result_list_lift]
      }
      result_list_lift
    }


    @externalName("[method]fields.has")
    foreign wasm wit_bindgen_methodFields_has: (WasmI32, WasmI32, WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Returns `true` when the key is present in this `fields`. If the key is
    /// syntactically invalid, `false` is returned.
    @unsafe
    provide let has: (Fields, FieldKey) -> Bool = (self, name) => {
      let vec_list_canon_lower = name
      let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
      let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
      let ret = wit_bindgen_methodFields_has(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), ptr_list_canon_lower, len_list_canon_lower)
      WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(ret, 31n), WasmI32.fromGrain(false))): Bool
    }


    @externalName("[method]fields.set")
    foreign wasm wit_bindgen_methodFields_set: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Set all of the values for a key. Clears any existing values for that
    /// key, if they have been set.
    /// 
    /// Fails with `header-error.immutable` if the `fields` are immutable.
    /// 
    /// Fails with `header-error.invalid-syntax` if the `field-key` or any of
    /// the `field-value`s are syntactically invalid.
    @unsafe
    provide let set: (Fields, FieldKey, List<FieldValue>) -> Result<Void, HeaderError> = (self, name, value) => {
      let vec_list_canon_lower = name
      let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
      let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
      let vec_list_lower = value
      let len_list_lower = WasmI32.(>>>)(WasmI32.fromGrain(List.length(vec_list_lower)), 1n)
      let result_list_lower = Memory.malloc(WasmI32.(*)(len_list_lower, 8n))
      let mut list = vec_list_lower
      let mut i = 0n
      while (true) {
        match (list) {
          [] => {
            break
          },
          [e, ...rest] => {
            list = rest
            let base = WasmI32.(+)(result_list_lower, WasmI32.(*)(i, 8n))
            i = WasmI32.(+)(i, 1n)
            let vec_list_canon_lower0 = e
            let ptr_list_canon_lower0 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower0), 8n)
            let len_list_canon_lower0 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower0), 4n)
            WasmI32.store(base, len_list_canon_lower0, 4n)
            WasmI32.store(base, ptr_list_canon_lower0, 0n)
          }
        }
      }
      wit_bindgen_methodFields_set(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), ptr_list_canon_lower, len_list_canon_lower, result_list_lower, len_list_lower, _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 1n)) {
            0n => {
              InvalidSyntax
            },
            1n => {
              Forbidden
            },
            _ => {
              Immutable
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]fields.delete")
    foreign wasm wit_bindgen_methodFields_delete: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Delete all values for a key. Does nothing if no values for the key
    /// exist.
    /// 
    /// Fails with `header-error.immutable` if the `fields` are immutable.
    /// 
    /// Fails with `header-error.invalid-syntax` if the `field-key` is
    /// syntactically invalid.
    @unsafe
    provide let delete: (Fields, FieldKey) -> Result<Void, HeaderError> = (self, name) => {
      let vec_list_canon_lower = name
      let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
      let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
      wit_bindgen_methodFields_delete(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), ptr_list_canon_lower, len_list_canon_lower, _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 1n)) {
            0n => {
              InvalidSyntax
            },
            1n => {
              Forbidden
            },
            _ => {
              Immutable
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]fields.append")
    foreign wasm wit_bindgen_methodFields_append: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Append a value for a key. Does not change or delete any existing
    /// values for that key.
    /// 
    /// Fails with `header-error.immutable` if the `fields` are immutable.
    /// 
    /// Fails with `header-error.invalid-syntax` if the `field-key` or
    /// `field-value` are syntactically invalid.
    @unsafe
    provide let append: (Fields, FieldKey, FieldValue) -> Result<Void, HeaderError> = (self, name, value) => {
      let vec_list_canon_lower = name
      let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
      let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
      let vec_list_canon_lower0 = value
      let ptr_list_canon_lower0 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower0), 8n)
      let len_list_canon_lower0 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower0), 4n)
      wit_bindgen_methodFields_append(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), ptr_list_canon_lower, len_list_canon_lower, ptr_list_canon_lower0, len_list_canon_lower0, _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 1n)) {
            0n => {
              InvalidSyntax
            },
            1n => {
              Forbidden
            },
            _ => {
              Immutable
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]fields.entries")
    foreign wasm wit_bindgen_methodFields_entries: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Retrieve the full set of keys and values in the Fields. Like the
    /// constructor, the list represents each key-value pair.
    /// 
    /// The outer list represents each key-value pair in the Fields. Keys
    /// which have multiple values are represented by multiple entries in this
    /// list with the same key.
    @unsafe
    provide let entries: (Fields) -> List<(FieldKey, FieldValue)> = (self) => {
      wit_bindgen_methodFields_entries(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      let base_list_lift = WasmI32.load(_RET_AREA, 0n)
      let len_list_lift = WasmI32.load(_RET_AREA, 4n)
      let mut result_list_lift = []
      Memory.incRef(WasmI32.fromGrain(result_list_lift))
      for (let mut i = WasmI32.(-)(len_list_lift, 1n); WasmI32.gtU(i, 0n); i = WasmI32.(-)(i, 1n)) {
        let base = WasmI32.(+)(base_list_lift, WasmI32.(*)(i, 16n))
        let len_string_lift = WasmI32.load(base, 4n)
        let str_string_lift = DataStructures.allocateString(len_string_lift)
        Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(base, 0n), len_string_lift)
        let str_string_lift = WasmI32.toGrain(str_string_lift): String
        let len_list_canon_lift = WasmI32.load(base, 12n)
        let bytes_list_canon_lift = DataStructures.allocateBytes(len_list_canon_lift)
        Memory.copy(WasmI32.(+)(bytes_list_canon_lift, 8n), WasmI32.load(base, 8n), len_list_canon_lift)
        let bytes_list_canon_lift = WasmI32.toGrain(bytes_list_canon_lift): Bytes
        result_list_lift = [(str_string_lift, bytes_list_canon_lift), ...result_list_lift]
      }
      result_list_lift
    }


    @externalName("[method]fields.clone")
    foreign wasm wit_bindgen_methodFields_clone: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Make a deep copy of the Fields. Equivelant in behavior to calling the
    /// `fields` constructor on the return value of `entries`. The resulting
    /// `fields` is mutable.
    @unsafe
    provide let clone: (Fields) -> Fields = (self) => {
      let ret = wit_bindgen_methodFields_clone(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Fields
      handle_lift
    }

  }

  provide module IncomingRequest {
    @externalName("[method]incoming-request.method")
    foreign wasm wit_bindgen_methodIncomingRequest_method: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the method of the incoming request.
    @unsafe
    provide let method: (IncomingRequest) -> Method = (self) => {
      wit_bindgen_methodIncomingRequest_method(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          Get
        },
        1n => {
          Head
        },
        2n => {
          Post
        },
        3n => {
          Put
        },
        4n => {
          Delete
        },
        5n => {
          Connect
        },
        6n => {
          Options
        },
        7n => {
          Trace
        },
        8n => {
          Patch
        },
        _ => {
          let len_string_lift = WasmI32.load(_RET_AREA, 8n)
          let str_string_lift = DataStructures.allocateString(len_string_lift)
          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_string_lift)
          let str_string_lift = WasmI32.toGrain(str_string_lift): String
          Other(str_string_lift)
        },
      }
    }


    @externalName("[method]incoming-request.path-with-query")
    foreign wasm wit_bindgen_methodIncomingRequest_pathWithQuery: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the path with query parameters from the request, as a string.
    @unsafe
    provide let pathWithQuery: (IncomingRequest) -> Option<String> = (self) => {
      wit_bindgen_methodIncomingRequest_pathWithQuery(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          let len_string_lift = WasmI32.load(_RET_AREA, 8n)
          let str_string_lift = DataStructures.allocateString(len_string_lift)
          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_string_lift)
          let str_string_lift = WasmI32.toGrain(str_string_lift): String

          Some(str_string_lift)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]incoming-request.scheme")
    foreign wasm wit_bindgen_methodIncomingRequest_scheme: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the protocol scheme from the request.
    @unsafe
    provide let scheme: (IncomingRequest) -> Option<Scheme> = (self) => {
      wit_bindgen_methodIncomingRequest_scheme(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          
          Some(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              Http
            },
            1n => {
              Https
            },
            _ => {
              let len_string_lift = WasmI32.load(_RET_AREA, 12n)
              let str_string_lift = DataStructures.allocateString(len_string_lift)
              Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 8n), len_string_lift)
              let str_string_lift = WasmI32.toGrain(str_string_lift): String
              Other(str_string_lift)
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]incoming-request.authority")
    foreign wasm wit_bindgen_methodIncomingRequest_authority: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the authority from the request, if it was present.
    @unsafe
    provide let authority: (IncomingRequest) -> Option<String> = (self) => {
      wit_bindgen_methodIncomingRequest_authority(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          let len_string_lift = WasmI32.load(_RET_AREA, 8n)
          let str_string_lift = DataStructures.allocateString(len_string_lift)
          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_string_lift)
          let str_string_lift = WasmI32.toGrain(str_string_lift): String

          Some(str_string_lift)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]incoming-request.headers")
    foreign wasm wit_bindgen_methodIncomingRequest_headers: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Get the `headers` associated with the request.
    /// 
    /// The returned `headers` resource is immutable: `set`, `append`, and
    /// `delete` operations will fail with `header-error.immutable`.
    /// 
    /// The `headers` returned are a child resource: it must be dropped before
    /// the parent `incoming-request` is dropped. Dropping this
    /// `incoming-request` before all children are dropped will trap.
    @unsafe
    provide let headers: (IncomingRequest) -> Headers = (self) => {
      let ret = wit_bindgen_methodIncomingRequest_headers(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Headers
      handle_lift
    }


    @externalName("[method]incoming-request.consume")
    foreign wasm wit_bindgen_methodIncomingRequest_consume: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Gives the `incoming-body` associated with this request. Will only
    /// return success at most once, and subsequent calls will return error.
    @unsafe
    provide let consume: (IncomingRequest) -> Result<IncomingBody, Void> = (self) => {
      wit_bindgen_methodIncomingRequest_consume(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IncomingBody

          Ok(handle_lift)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }

  provide module OutgoingRequest {
    @externalName("[constructor]outgoing-request")
    foreign wasm wit_bindgen_constructorOutgoingRequest: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Construct a new `outgoing-request` with a default `method` of `GET`, and
    /// `none` values for `path-with-query`, `scheme`, and `authority`.
    /// 
    /// * `headers` is the HTTP Headers for the Request.
    /// 
    /// It is possible to construct, or manipulate with the accessor functions
    /// below, an `outgoing-request` with an invalid combination of `scheme`
    /// and `authority`, or `headers` which are not permitted to be sent.
    /// It is the obligation of the `outgoing-handler.handle` implementation
    /// to reject invalid constructions of `outgoing-request`.
    @unsafe
    provide let constructor: (Headers) -> OutgoingRequest = (headers) => {
      let ret = wit_bindgen_constructorOutgoingRequest(WasmI32.load(WasmI32.fromGrain(headers.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: OutgoingRequest
      handle_lift
    }


    @externalName("[method]outgoing-request.body")
    foreign wasm wit_bindgen_methodOutgoingRequest_body: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the resource corresponding to the outgoing Body for this
    /// Request.
    /// 
    /// Returns success on the first call: the `outgoing-body` resource for
    /// this `outgoing-request` can be retrieved at most once. Subsequent
    /// calls will return error.
    @unsafe
    provide let body: (OutgoingRequest) -> Result<OutgoingBody, Void> = (self) => {
      wit_bindgen_methodOutgoingRequest_body(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: OutgoingBody

          Ok(handle_lift)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.method")
    foreign wasm wit_bindgen_methodOutgoingRequest_method: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Get the Method for the Request.
    @unsafe
    provide let method: (OutgoingRequest) -> Method = (self) => {
      wit_bindgen_methodOutgoingRequest_method(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          Get
        },
        1n => {
          Head
        },
        2n => {
          Post
        },
        3n => {
          Put
        },
        4n => {
          Delete
        },
        5n => {
          Connect
        },
        6n => {
          Options
        },
        7n => {
          Trace
        },
        8n => {
          Patch
        },
        _ => {
          let len_string_lift = WasmI32.load(_RET_AREA, 8n)
          let str_string_lift = DataStructures.allocateString(len_string_lift)
          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_string_lift)
          let str_string_lift = WasmI32.toGrain(str_string_lift): String
          Other(str_string_lift)
        },
      }
    }


    @externalName("[method]outgoing-request.set-method")
    foreign wasm wit_bindgen_methodOutgoingRequest_setMethod: (WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the Method for the Request. Fails if the string present in a
    /// `method.other` argument is not a syntactically valid method.
    @unsafe
    provide let setMethod: (OutgoingRequest, Method) -> Result<Void, Void> = (self, method) => {
      let mut resultvariant_lower_0 = 0n
      let mut resultvariant_lower_1 = 0n
      let mut resultvariant_lower_2 = 0n
      match (method) {
        Get => {
          resultvariant_lower_0 = 0n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Head => {
          resultvariant_lower_0 = 1n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Post => {
          resultvariant_lower_0 = 2n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Put => {
          resultvariant_lower_0 = 3n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Delete => {
          resultvariant_lower_0 = 4n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Connect => {
          resultvariant_lower_0 = 5n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Options => {
          resultvariant_lower_0 = 6n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Trace => {
          resultvariant_lower_0 = 7n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Patch => {
          resultvariant_lower_0 = 8n
          resultvariant_lower_1 = 0n
          resultvariant_lower_2 = 0n
        },
        Other(e) => {
          let vec_list_canon_lower = e
          let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
          let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
          resultvariant_lower_0 = 9n
          resultvariant_lower_1 = ptr_list_canon_lower
          resultvariant_lower_2 = len_list_canon_lower
        },
      }
      let ret = wit_bindgen_methodOutgoingRequest_setMethod(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), resultvariant_lower_0, resultvariant_lower_1, resultvariant_lower_2)
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.path-with-query")
    foreign wasm wit_bindgen_methodOutgoingRequest_pathWithQuery: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Get the combination of the HTTP Path and Query for the Request.
    /// When `none`, this represents an empty Path and empty Query.
    @unsafe
    provide let pathWithQuery: (OutgoingRequest) -> Option<String> = (self) => {
      wit_bindgen_methodOutgoingRequest_pathWithQuery(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          let len_string_lift = WasmI32.load(_RET_AREA, 8n)
          let str_string_lift = DataStructures.allocateString(len_string_lift)
          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_string_lift)
          let str_string_lift = WasmI32.toGrain(str_string_lift): String

          Some(str_string_lift)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.set-path-with-query")
    foreign wasm wit_bindgen_methodOutgoingRequest_setPathWithQuery: (WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the combination of the HTTP Path and Query for the Request.
    /// When `none`, this represents an empty Path and empty Query. Fails is the
    /// string given is not a syntactically valid path and query uri component.
    @unsafe
    provide let setPathWithQuery: (OutgoingRequest, Option<String>) -> Result<Void, Void> = (self, pathWithQuery) => {
      let mut resultoption_lower_0 = 0n
      let mut resultoption_lower_1 = 0n
      let mut resultoption_lower_2 = 0n
      match (pathWithQuery) {
        Some(e) => {
          let vec_list_canon_lower = e
          let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
          let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
          resultoption_lower_0 = 1n
          resultoption_lower_1 = ptr_list_canon_lower
          resultoption_lower_2 = len_list_canon_lower
        },
        None => {
          resultoption_lower_0 = 0n
          resultoption_lower_1 = 0n
          resultoption_lower_2 = 0n
        },
      }
      let ret = wit_bindgen_methodOutgoingRequest_setPathWithQuery(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), resultoption_lower_0, resultoption_lower_1, resultoption_lower_2)
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.scheme")
    foreign wasm wit_bindgen_methodOutgoingRequest_scheme: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Get the HTTP Related Scheme for the Request. When `none`, the
    /// implementation may choose an appropriate default scheme.
    @unsafe
    provide let scheme: (OutgoingRequest) -> Option<Scheme> = (self) => {
      wit_bindgen_methodOutgoingRequest_scheme(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          
          Some(match (WasmI32.load8U(_RET_AREA, 4n)) {
            0n => {
              Http
            },
            1n => {
              Https
            },
            _ => {
              let len_string_lift = WasmI32.load(_RET_AREA, 12n)
              let str_string_lift = DataStructures.allocateString(len_string_lift)
              Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 8n), len_string_lift)
              let str_string_lift = WasmI32.toGrain(str_string_lift): String
              Other(str_string_lift)
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.set-scheme")
    foreign wasm wit_bindgen_methodOutgoingRequest_setScheme: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the HTTP Related Scheme for the Request. When `none`, the
    /// implementation may choose an appropriate default scheme. Fails if the
    /// string given is not a syntactically valid uri scheme.
    @unsafe
    provide let setScheme: (OutgoingRequest, Option<Scheme>) -> Result<Void, Void> = (self, scheme) => {
      let mut resultoption_lower_0 = 0n
      let mut resultoption_lower_1 = 0n
      let mut resultoption_lower_2 = 0n
      let mut resultoption_lower_3 = 0n
      match (scheme) {
        Some(e) => {
          let mut resultvariant_lower_0 = 0n
          let mut resultvariant_lower_1 = 0n
          let mut resultvariant_lower_2 = 0n
          match (e) {
            Http => {
              resultvariant_lower_0 = 0n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0n
            },
            Https => {
              resultvariant_lower_0 = 1n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0n
            },
            Other(e) => {
              let vec_list_canon_lower = e
              let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
              let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
              resultvariant_lower_0 = 2n
              resultvariant_lower_1 = ptr_list_canon_lower
              resultvariant_lower_2 = len_list_canon_lower
            },
          }
          resultoption_lower_0 = 1n
          resultoption_lower_1 = resultvariant_lower_0
          resultoption_lower_2 = resultvariant_lower_1
          resultoption_lower_3 = resultvariant_lower_2
        },
        None => {
          resultoption_lower_0 = 0n
          resultoption_lower_1 = 0n
          resultoption_lower_2 = 0n
          resultoption_lower_3 = 0n
        },
      }
      let ret = wit_bindgen_methodOutgoingRequest_setScheme(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), resultoption_lower_0, resultoption_lower_1, resultoption_lower_2, resultoption_lower_3)
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.authority")
    foreign wasm wit_bindgen_methodOutgoingRequest_authority: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Get the HTTP Authority for the Request. A value of `none` may be used
    /// with Related Schemes which do not require an Authority. The HTTP and
    /// HTTPS schemes always require an authority.
    @unsafe
    provide let authority: (OutgoingRequest) -> Option<String> = (self) => {
      wit_bindgen_methodOutgoingRequest_authority(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          let len_string_lift = WasmI32.load(_RET_AREA, 8n)
          let str_string_lift = DataStructures.allocateString(len_string_lift)
          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 4n), len_string_lift)
          let str_string_lift = WasmI32.toGrain(str_string_lift): String

          Some(str_string_lift)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.set-authority")
    foreign wasm wit_bindgen_methodOutgoingRequest_setAuthority: (WasmI32, WasmI32, WasmI32, WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the HTTP Authority for the Request. A value of `none` may be used
    /// with Related Schemes which do not require an Authority. The HTTP and
    /// HTTPS schemes always require an authority. Fails if the string given is
    /// not a syntactically valid uri authority.
    @unsafe
    provide let setAuthority: (OutgoingRequest, Option<String>) -> Result<Void, Void> = (self, authority) => {
      let mut resultoption_lower_0 = 0n
      let mut resultoption_lower_1 = 0n
      let mut resultoption_lower_2 = 0n
      match (authority) {
        Some(e) => {
          let vec_list_canon_lower = e
          let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
          let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
          resultoption_lower_0 = 1n
          resultoption_lower_1 = ptr_list_canon_lower
          resultoption_lower_2 = len_list_canon_lower
        },
        None => {
          resultoption_lower_0 = 0n
          resultoption_lower_1 = 0n
          resultoption_lower_2 = 0n
        },
      }
      let ret = wit_bindgen_methodOutgoingRequest_setAuthority(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), resultoption_lower_0, resultoption_lower_1, resultoption_lower_2)
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-request.headers")
    foreign wasm wit_bindgen_methodOutgoingRequest_headers: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Get the headers associated with the Request.
    /// 
    /// The returned `headers` resource is immutable: `set`, `append`, and
    /// `delete` operations will fail with `header-error.immutable`.
    /// 
    /// This headers resource is a child: it must be dropped before the parent
    /// `outgoing-request` is dropped, or its ownership is transfered to
    /// another component by e.g. `outgoing-handler.handle`.
    @unsafe
    provide let headers: (OutgoingRequest) -> Headers = (self) => {
      let ret = wit_bindgen_methodOutgoingRequest_headers(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Headers
      handle_lift
    }

  }

  provide module RequestOptions {
    @externalName("[constructor]request-options")
    foreign wasm wit_bindgen_constructorRequestOptions: () -> WasmI32 from "wasi:http/types@0.2.0"

    /// Construct a default `request-options` value.
    @unsafe
    provide let constructor: () -> RequestOptions = () => {
      let ret = wit_bindgen_constructorRequestOptions()
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: RequestOptions
      handle_lift
    }


    @externalName("[method]request-options.connect-timeout")
    foreign wasm wit_bindgen_methodRequestOptions_connectTimeout: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// The timeout for the initial connect to the HTTP Server.
    @unsafe
    provide let connectTimeout: (RequestOptions) -> Option<Duration> = (self) => {
      wit_bindgen_methodRequestOptions_connectTimeout(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          
          Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]request-options.set-connect-timeout")
    foreign wasm wit_bindgen_methodRequestOptions_setConnectTimeout: (WasmI32, WasmI32, WasmI64) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the timeout for the initial connect to the HTTP Server. An error
    /// return value indicates that this timeout is not supported.
    @unsafe
    provide let setConnectTimeout: (RequestOptions, Option<Duration>) -> Result<Void, Void> = (self, duration) => {
      let mut resultoption_lower_0 = 0n
      let mut resultoption_lower_1 = 0N
      match (duration) {
        Some(e) => {
          resultoption_lower_0 = 1n
          resultoption_lower_1 = WasmI64.load(WasmI32.fromGrain(e), 8n)
        },
        None => {
          resultoption_lower_0 = 0n
          resultoption_lower_1 = 0N
        },
      }
      let ret = wit_bindgen_methodRequestOptions_setConnectTimeout(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), resultoption_lower_0, resultoption_lower_1)
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]request-options.first-byte-timeout")
    foreign wasm wit_bindgen_methodRequestOptions_firstByteTimeout: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// The timeout for receiving the first byte of the Response body.
    @unsafe
    provide let firstByteTimeout: (RequestOptions) -> Option<Duration> = (self) => {
      wit_bindgen_methodRequestOptions_firstByteTimeout(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          
          Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]request-options.set-first-byte-timeout")
    foreign wasm wit_bindgen_methodRequestOptions_setFirstByteTimeout: (WasmI32, WasmI32, WasmI64) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the timeout for receiving the first byte of the Response body. An
    /// error return value indicates that this timeout is not supported.
    @unsafe
    provide let setFirstByteTimeout: (RequestOptions, Option<Duration>) -> Result<Void, Void> = (self, duration) => {
      let mut resultoption_lower_0 = 0n
      let mut resultoption_lower_1 = 0N
      match (duration) {
        Some(e) => {
          resultoption_lower_0 = 1n
          resultoption_lower_1 = WasmI64.load(WasmI32.fromGrain(e), 8n)
        },
        None => {
          resultoption_lower_0 = 0n
          resultoption_lower_1 = 0N
        },
      }
      let ret = wit_bindgen_methodRequestOptions_setFirstByteTimeout(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), resultoption_lower_0, resultoption_lower_1)
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]request-options.between-bytes-timeout")
    foreign wasm wit_bindgen_methodRequestOptions_betweenBytesTimeout: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// The timeout for receiving subsequent chunks of bytes in the Response
    /// body stream.
    @unsafe
    provide let betweenBytesTimeout: (RequestOptions) -> Option<Duration> = (self) => {
      wit_bindgen_methodRequestOptions_betweenBytesTimeout(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          
          Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 8n))): Uint64)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]request-options.set-between-bytes-timeout")
    foreign wasm wit_bindgen_methodRequestOptions_setBetweenBytesTimeout: (WasmI32, WasmI32, WasmI64) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the timeout for receiving subsequent chunks of bytes in the Response
    /// body stream. An error return value indicates that this timeout is not
    /// supported.
    @unsafe
    provide let setBetweenBytesTimeout: (RequestOptions, Option<Duration>) -> Result<Void, Void> = (self, duration) => {
      let mut resultoption_lower_0 = 0n
      let mut resultoption_lower_1 = 0N
      match (duration) {
        Some(e) => {
          resultoption_lower_0 = 1n
          resultoption_lower_1 = WasmI64.load(WasmI32.fromGrain(e), 8n)
        },
        None => {
          resultoption_lower_0 = 0n
          resultoption_lower_1 = 0N
        },
      }
      let ret = wit_bindgen_methodRequestOptions_setBetweenBytesTimeout(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), resultoption_lower_0, resultoption_lower_1)
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }

  provide module ResponseOutparam {
    @externalName("[static]response-outparam.set")
    foreign wasm wit_bindgen_staticResponseOutparam_set: (WasmI32, WasmI32, WasmI32, WasmI32, WasmI64, WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Set the value of the `response-outparam` to either send a response,
    /// or indicate an error.
    /// 
    /// This method consumes the `response-outparam` to ensure that it is
    /// called at most once. If it is never called, the implementation
    /// will respond with an error.
    /// 
    /// The user may provide an `error` to `response` to allow the
    /// implementation determine how to respond with an HTTP error response.
    @unsafe
    provide let set: (ResponseOutparam, Result<OutgoingResponse, ErrorCode>) -> Void = (param, response) => {
      let mut resultresult_lower_0 = 0n
      let mut resultresult_lower_1 = 0n
      let mut resultresult_lower_2 = 0n
      let mut resultresult_lower_3 = 0N
      let mut resultresult_lower_4 = 0n
      let mut resultresult_lower_5 = 0n
      let mut resultresult_lower_6 = 0n
      let mut resultresult_lower_7 = 0n
      match (response) {
        Ok(e) => {
          resultresult_lower_0 = 0n
          resultresult_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
          resultresult_lower_2 = 0n
          resultresult_lower_3 = 0N
          resultresult_lower_4 = 0n
          resultresult_lower_5 = 0n
          resultresult_lower_6 = 0n
          resultresult_lower_7 = 0n

        },
        Err(e) => {
          let mut resultvariant_lower_0 = 0n
          let mut resultvariant_lower_1 = 0n
          let mut resultvariant_lower_2 = 0N
          let mut resultvariant_lower_3 = 0n
          let mut resultvariant_lower_4 = 0n
          let mut resultvariant_lower_5 = 0n
          let mut resultvariant_lower_6 = 0n
          match (e) {
            DnsTimeout => {
              resultvariant_lower_0 = 0n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            DnsError(e) => {
              let { rcode: rcoderecord, infoCode: infoCoderecord }: DnsErrorPayload = e
              let mut resultoption_lower_0 = 0n
              let mut resultoption_lower_1 = 0n
              let mut resultoption_lower_2 = 0n
              match (rcoderecord) {
                Some(e) => {
                  let vec_list_canon_lower = e
                  let ptr_list_canon_lower = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower), 8n)
                  let len_list_canon_lower = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower), 4n)
                  resultoption_lower_0 = 1n
                  resultoption_lower_1 = ptr_list_canon_lower
                  resultoption_lower_2 = len_list_canon_lower
                },
                None => {
                  resultoption_lower_0 = 0n
                  resultoption_lower_1 = 0n
                  resultoption_lower_2 = 0n
                },
              }
              let mut resultoption_lower0_0 = 0n
              let mut resultoption_lower0_1 = 0n
              match (infoCoderecord) {
                Some(e) => {
                  resultoption_lower0_0 = 1n
                  resultoption_lower0_1 = WasmI32.(>>>)(WasmI32.fromGrain(e), 8n)
                },
                None => {
                  resultoption_lower0_0 = 0n
                  resultoption_lower0_1 = 0n
                },
              }
              resultvariant_lower_0 = 1n
              resultvariant_lower_1 = resultoption_lower_0
              resultvariant_lower_2 = WasmI64.extendI32U(resultoption_lower_1)
              resultvariant_lower_3 = resultoption_lower_2
              resultvariant_lower_4 = resultoption_lower0_0
              resultvariant_lower_5 = resultoption_lower0_1
              resultvariant_lower_6 = 0n
            },
            DestinationNotFound => {
              resultvariant_lower_0 = 2n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            DestinationUnavailable => {
              resultvariant_lower_0 = 3n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            DestinationIpProhibited => {
              resultvariant_lower_0 = 4n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            DestinationIpUnroutable => {
              resultvariant_lower_0 = 5n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            ConnectionRefused => {
              resultvariant_lower_0 = 6n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            ConnectionTerminated => {
              resultvariant_lower_0 = 7n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            ConnectionTimeout => {
              resultvariant_lower_0 = 8n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            ConnectionReadTimeout => {
              resultvariant_lower_0 = 9n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            ConnectionWriteTimeout => {
              resultvariant_lower_0 = 10n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            ConnectionLimitReached => {
              resultvariant_lower_0 = 11n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            TlsProtocolError => {
              resultvariant_lower_0 = 12n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            TlsCertificateError => {
              resultvariant_lower_0 = 13n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            TlsAlertReceived(e) => {
              let { alertId: alertIdrecord1, alertMessage: alertMessagerecord1 }: TlsAlertReceivedPayload = e
              let mut resultoption_lower2_0 = 0n
              let mut resultoption_lower2_1 = 0n
              match (alertIdrecord1) {
                Some(e) => {
                  resultoption_lower2_0 = 1n
                  resultoption_lower2_1 = WasmI32.(>>>)(WasmI32.fromGrain(e), 8n)
                },
                None => {
                  resultoption_lower2_0 = 0n
                  resultoption_lower2_1 = 0n
                },
              }
              let mut resultoption_lower4_0 = 0n
              let mut resultoption_lower4_1 = 0n
              let mut resultoption_lower4_2 = 0n
              match (alertMessagerecord1) {
                Some(e) => {
                  let vec_list_canon_lower3 = e
                  let ptr_list_canon_lower3 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower3), 8n)
                  let len_list_canon_lower3 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower3), 4n)
                  resultoption_lower4_0 = 1n
                  resultoption_lower4_1 = ptr_list_canon_lower3
                  resultoption_lower4_2 = len_list_canon_lower3
                },
                None => {
                  resultoption_lower4_0 = 0n
                  resultoption_lower4_1 = 0n
                  resultoption_lower4_2 = 0n
                },
              }
              resultvariant_lower_0 = 14n
              resultvariant_lower_1 = resultoption_lower2_0
              resultvariant_lower_2 = WasmI64.extendI32S(resultoption_lower2_1)
              resultvariant_lower_3 = resultoption_lower4_0
              resultvariant_lower_4 = resultoption_lower4_1
              resultvariant_lower_5 = resultoption_lower4_2
              resultvariant_lower_6 = 0n
            },
            HttpRequestDenied => {
              resultvariant_lower_0 = 15n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestLengthRequired => {
              resultvariant_lower_0 = 16n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestBodySize(e) => {
              let mut resultoption_lower5_0 = 0n
              let mut resultoption_lower5_1 = 0N
              match (e) {
                Some(e) => {
                  resultoption_lower5_0 = 1n
                  resultoption_lower5_1 = WasmI64.load(WasmI32.fromGrain(e), 8n)
                },
                None => {
                  resultoption_lower5_0 = 0n
                  resultoption_lower5_1 = 0N
                },
              }
              resultvariant_lower_0 = 17n
              resultvariant_lower_1 = resultoption_lower5_0
              resultvariant_lower_2 = resultoption_lower5_1
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestMethodInvalid => {
              resultvariant_lower_0 = 18n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestUriInvalid => {
              resultvariant_lower_0 = 19n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestUriTooLong => {
              resultvariant_lower_0 = 20n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestHeaderSectionSize(e) => {
              let mut resultoption_lower6_0 = 0n
              let mut resultoption_lower6_1 = 0n
              match (e) {
                Some(e) => {
                  resultoption_lower6_0 = 1n
                  resultoption_lower6_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                },
                None => {
                  resultoption_lower6_0 = 0n
                  resultoption_lower6_1 = 0n
                },
              }
              resultvariant_lower_0 = 21n
              resultvariant_lower_1 = resultoption_lower6_0
              resultvariant_lower_2 = WasmI64.extendI32S(resultoption_lower6_1)
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestHeaderSize(e) => {
              let mut resultoption_lower11_0 = 0n
              let mut resultoption_lower11_1 = 0n
              let mut resultoption_lower11_2 = 0n
              let mut resultoption_lower11_3 = 0n
              let mut resultoption_lower11_4 = 0n
              let mut resultoption_lower11_5 = 0n
              match (e) {
                Some(e) => {
                  let { fieldName: fieldNamerecord7, fieldSize: fieldSizerecord7 }: FieldSizePayload = e
                  let mut resultoption_lower9_0 = 0n
                  let mut resultoption_lower9_1 = 0n
                  let mut resultoption_lower9_2 = 0n
                  match (fieldNamerecord7) {
                    Some(e) => {
                      let vec_list_canon_lower8 = e
                      let ptr_list_canon_lower8 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower8), 8n)
                      let len_list_canon_lower8 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower8), 4n)
                      resultoption_lower9_0 = 1n
                      resultoption_lower9_1 = ptr_list_canon_lower8
                      resultoption_lower9_2 = len_list_canon_lower8
                    },
                    None => {
                      resultoption_lower9_0 = 0n
                      resultoption_lower9_1 = 0n
                      resultoption_lower9_2 = 0n
                    },
                  }
                  let mut resultoption_lower10_0 = 0n
                  let mut resultoption_lower10_1 = 0n
                  match (fieldSizerecord7) {
                    Some(e) => {
                      resultoption_lower10_0 = 1n
                      resultoption_lower10_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                    },
                    None => {
                      resultoption_lower10_0 = 0n
                      resultoption_lower10_1 = 0n
                    },
                  }
                  resultoption_lower11_0 = 1n
                  resultoption_lower11_1 = resultoption_lower9_0
                  resultoption_lower11_2 = resultoption_lower9_1
                  resultoption_lower11_3 = resultoption_lower9_2
                  resultoption_lower11_4 = resultoption_lower10_0
                  resultoption_lower11_5 = resultoption_lower10_1
                },
                None => {
                  resultoption_lower11_0 = 0n
                  resultoption_lower11_1 = 0n
                  resultoption_lower11_2 = 0n
                  resultoption_lower11_3 = 0n
                  resultoption_lower11_4 = 0n
                  resultoption_lower11_5 = 0n
                },
              }
              resultvariant_lower_0 = 22n
              resultvariant_lower_1 = resultoption_lower11_0
              resultvariant_lower_2 = WasmI64.extendI32S(resultoption_lower11_1)
              resultvariant_lower_3 = resultoption_lower11_2
              resultvariant_lower_4 = resultoption_lower11_3
              resultvariant_lower_5 = resultoption_lower11_4
              resultvariant_lower_6 = resultoption_lower11_5
            },
            HttpRequestTrailerSectionSize(e) => {
              let mut resultoption_lower12_0 = 0n
              let mut resultoption_lower12_1 = 0n
              match (e) {
                Some(e) => {
                  resultoption_lower12_0 = 1n
                  resultoption_lower12_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                },
                None => {
                  resultoption_lower12_0 = 0n
                  resultoption_lower12_1 = 0n
                },
              }
              resultvariant_lower_0 = 23n
              resultvariant_lower_1 = resultoption_lower12_0
              resultvariant_lower_2 = WasmI64.extendI32S(resultoption_lower12_1)
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpRequestTrailerSize(e) => {
              let { fieldName: fieldNamerecord13, fieldSize: fieldSizerecord13 }: FieldSizePayload = e
              let mut resultoption_lower15_0 = 0n
              let mut resultoption_lower15_1 = 0n
              let mut resultoption_lower15_2 = 0n
              match (fieldNamerecord13) {
                Some(e) => {
                  let vec_list_canon_lower14 = e
                  let ptr_list_canon_lower14 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower14), 8n)
                  let len_list_canon_lower14 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower14), 4n)
                  resultoption_lower15_0 = 1n
                  resultoption_lower15_1 = ptr_list_canon_lower14
                  resultoption_lower15_2 = len_list_canon_lower14
                },
                None => {
                  resultoption_lower15_0 = 0n
                  resultoption_lower15_1 = 0n
                  resultoption_lower15_2 = 0n
                },
              }
              let mut resultoption_lower16_0 = 0n
              let mut resultoption_lower16_1 = 0n
              match (fieldSizerecord13) {
                Some(e) => {
                  resultoption_lower16_0 = 1n
                  resultoption_lower16_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                },
                None => {
                  resultoption_lower16_0 = 0n
                  resultoption_lower16_1 = 0n
                },
              }
              resultvariant_lower_0 = 24n
              resultvariant_lower_1 = resultoption_lower15_0
              resultvariant_lower_2 = WasmI64.extendI32U(resultoption_lower15_1)
              resultvariant_lower_3 = resultoption_lower15_2
              resultvariant_lower_4 = resultoption_lower16_0
              resultvariant_lower_5 = resultoption_lower16_1
              resultvariant_lower_6 = 0n
            },
            HttpResponseIncomplete => {
              resultvariant_lower_0 = 25n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpResponseHeaderSectionSize(e) => {
              let mut resultoption_lower17_0 = 0n
              let mut resultoption_lower17_1 = 0n
              match (e) {
                Some(e) => {
                  resultoption_lower17_0 = 1n
                  resultoption_lower17_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                },
                None => {
                  resultoption_lower17_0 = 0n
                  resultoption_lower17_1 = 0n
                },
              }
              resultvariant_lower_0 = 26n
              resultvariant_lower_1 = resultoption_lower17_0
              resultvariant_lower_2 = WasmI64.extendI32S(resultoption_lower17_1)
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpResponseHeaderSize(e) => {
              let { fieldName: fieldNamerecord18, fieldSize: fieldSizerecord18 }: FieldSizePayload = e
              let mut resultoption_lower20_0 = 0n
              let mut resultoption_lower20_1 = 0n
              let mut resultoption_lower20_2 = 0n
              match (fieldNamerecord18) {
                Some(e) => {
                  let vec_list_canon_lower19 = e
                  let ptr_list_canon_lower19 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower19), 8n)
                  let len_list_canon_lower19 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower19), 4n)
                  resultoption_lower20_0 = 1n
                  resultoption_lower20_1 = ptr_list_canon_lower19
                  resultoption_lower20_2 = len_list_canon_lower19
                },
                None => {
                  resultoption_lower20_0 = 0n
                  resultoption_lower20_1 = 0n
                  resultoption_lower20_2 = 0n
                },
              }
              let mut resultoption_lower21_0 = 0n
              let mut resultoption_lower21_1 = 0n
              match (fieldSizerecord18) {
                Some(e) => {
                  resultoption_lower21_0 = 1n
                  resultoption_lower21_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                },
                None => {
                  resultoption_lower21_0 = 0n
                  resultoption_lower21_1 = 0n
                },
              }
              resultvariant_lower_0 = 27n
              resultvariant_lower_1 = resultoption_lower20_0
              resultvariant_lower_2 = WasmI64.extendI32U(resultoption_lower20_1)
              resultvariant_lower_3 = resultoption_lower20_2
              resultvariant_lower_4 = resultoption_lower21_0
              resultvariant_lower_5 = resultoption_lower21_1
              resultvariant_lower_6 = 0n
            },
            HttpResponseBodySize(e) => {
              let mut resultoption_lower22_0 = 0n
              let mut resultoption_lower22_1 = 0N
              match (e) {
                Some(e) => {
                  resultoption_lower22_0 = 1n
                  resultoption_lower22_1 = WasmI64.load(WasmI32.fromGrain(e), 8n)
                },
                None => {
                  resultoption_lower22_0 = 0n
                  resultoption_lower22_1 = 0N
                },
              }
              resultvariant_lower_0 = 28n
              resultvariant_lower_1 = resultoption_lower22_0
              resultvariant_lower_2 = resultoption_lower22_1
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpResponseTrailerSectionSize(e) => {
              let mut resultoption_lower23_0 = 0n
              let mut resultoption_lower23_1 = 0n
              match (e) {
                Some(e) => {
                  resultoption_lower23_0 = 1n
                  resultoption_lower23_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                },
                None => {
                  resultoption_lower23_0 = 0n
                  resultoption_lower23_1 = 0n
                },
              }
              resultvariant_lower_0 = 29n
              resultvariant_lower_1 = resultoption_lower23_0
              resultvariant_lower_2 = WasmI64.extendI32S(resultoption_lower23_1)
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpResponseTrailerSize(e) => {
              let { fieldName: fieldNamerecord24, fieldSize: fieldSizerecord24 }: FieldSizePayload = e
              let mut resultoption_lower26_0 = 0n
              let mut resultoption_lower26_1 = 0n
              let mut resultoption_lower26_2 = 0n
              match (fieldNamerecord24) {
                Some(e) => {
                  let vec_list_canon_lower25 = e
                  let ptr_list_canon_lower25 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower25), 8n)
                  let len_list_canon_lower25 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower25), 4n)
                  resultoption_lower26_0 = 1n
                  resultoption_lower26_1 = ptr_list_canon_lower25
                  resultoption_lower26_2 = len_list_canon_lower25
                },
                None => {
                  resultoption_lower26_0 = 0n
                  resultoption_lower26_1 = 0n
                  resultoption_lower26_2 = 0n
                },
              }
              let mut resultoption_lower27_0 = 0n
              let mut resultoption_lower27_1 = 0n
              match (fieldSizerecord24) {
                Some(e) => {
                  resultoption_lower27_0 = 1n
                  resultoption_lower27_1 = WasmI32.load(WasmI32.fromGrain(e), 4n)
                },
                None => {
                  resultoption_lower27_0 = 0n
                  resultoption_lower27_1 = 0n
                },
              }
              resultvariant_lower_0 = 30n
              resultvariant_lower_1 = resultoption_lower26_0
              resultvariant_lower_2 = WasmI64.extendI32U(resultoption_lower26_1)
              resultvariant_lower_3 = resultoption_lower26_2
              resultvariant_lower_4 = resultoption_lower27_0
              resultvariant_lower_5 = resultoption_lower27_1
              resultvariant_lower_6 = 0n
            },
            HttpResponseTransferCoding(e) => {
              let mut resultoption_lower29_0 = 0n
              let mut resultoption_lower29_1 = 0n
              let mut resultoption_lower29_2 = 0n
              match (e) {
                Some(e) => {
                  let vec_list_canon_lower28 = e
                  let ptr_list_canon_lower28 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower28), 8n)
                  let len_list_canon_lower28 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower28), 4n)
                  resultoption_lower29_0 = 1n
                  resultoption_lower29_1 = ptr_list_canon_lower28
                  resultoption_lower29_2 = len_list_canon_lower28
                },
                None => {
                  resultoption_lower29_0 = 0n
                  resultoption_lower29_1 = 0n
                  resultoption_lower29_2 = 0n
                },
              }
              resultvariant_lower_0 = 31n
              resultvariant_lower_1 = resultoption_lower29_0
              resultvariant_lower_2 = WasmI64.extendI32U(resultoption_lower29_1)
              resultvariant_lower_3 = resultoption_lower29_2
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpResponseContentCoding(e) => {
              let mut resultoption_lower31_0 = 0n
              let mut resultoption_lower31_1 = 0n
              let mut resultoption_lower31_2 = 0n
              match (e) {
                Some(e) => {
                  let vec_list_canon_lower30 = e
                  let ptr_list_canon_lower30 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower30), 8n)
                  let len_list_canon_lower30 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower30), 4n)
                  resultoption_lower31_0 = 1n
                  resultoption_lower31_1 = ptr_list_canon_lower30
                  resultoption_lower31_2 = len_list_canon_lower30
                },
                None => {
                  resultoption_lower31_0 = 0n
                  resultoption_lower31_1 = 0n
                  resultoption_lower31_2 = 0n
                },
              }
              resultvariant_lower_0 = 32n
              resultvariant_lower_1 = resultoption_lower31_0
              resultvariant_lower_2 = WasmI64.extendI32U(resultoption_lower31_1)
              resultvariant_lower_3 = resultoption_lower31_2
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpResponseTimeout => {
              resultvariant_lower_0 = 33n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpUpgradeFailed => {
              resultvariant_lower_0 = 34n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            HttpProtocolError => {
              resultvariant_lower_0 = 35n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            LoopDetected => {
              resultvariant_lower_0 = 36n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            ConfigurationError => {
              resultvariant_lower_0 = 37n
              resultvariant_lower_1 = 0n
              resultvariant_lower_2 = 0N
              resultvariant_lower_3 = 0n
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
            InternalError(e) => {
              let mut resultoption_lower33_0 = 0n
              let mut resultoption_lower33_1 = 0n
              let mut resultoption_lower33_2 = 0n
              match (e) {
                Some(e) => {
                  let vec_list_canon_lower32 = e
                  let ptr_list_canon_lower32 = WasmI32.(+)(WasmI32.fromGrain(vec_list_canon_lower32), 8n)
                  let len_list_canon_lower32 = WasmI32.load(WasmI32.fromGrain(vec_list_canon_lower32), 4n)
                  resultoption_lower33_0 = 1n
                  resultoption_lower33_1 = ptr_list_canon_lower32
                  resultoption_lower33_2 = len_list_canon_lower32
                },
                None => {
                  resultoption_lower33_0 = 0n
                  resultoption_lower33_1 = 0n
                  resultoption_lower33_2 = 0n
                },
              }
              resultvariant_lower_0 = 38n
              resultvariant_lower_1 = resultoption_lower33_0
              resultvariant_lower_2 = WasmI64.extendI32U(resultoption_lower33_1)
              resultvariant_lower_3 = resultoption_lower33_2
              resultvariant_lower_4 = 0n
              resultvariant_lower_5 = 0n
              resultvariant_lower_6 = 0n
            },
          }
          resultresult_lower_0 = 1n
          resultresult_lower_1 = resultvariant_lower_0
          resultresult_lower_2 = resultvariant_lower_1
          resultresult_lower_3 = resultvariant_lower_2
          resultresult_lower_4 = resultvariant_lower_3
          resultresult_lower_5 = resultvariant_lower_4
          resultresult_lower_6 = resultvariant_lower_5
          resultresult_lower_7 = resultvariant_lower_6

        },
      }
      wit_bindgen_staticResponseOutparam_set(WasmI32.load(WasmI32.fromGrain(param.handle), 4n), resultresult_lower_0, resultresult_lower_1, resultresult_lower_2, resultresult_lower_3, resultresult_lower_4, resultresult_lower_5, resultresult_lower_6, resultresult_lower_7)
      void
    }

  }

  provide module IncomingResponse {
    @externalName("[method]incoming-response.status")
    foreign wasm wit_bindgen_methodIncomingResponse_status: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Returns the status code from the incoming response.
    @unsafe
    provide let status: (IncomingResponse) -> StatusCode = (self) => {
      let ret = wit_bindgen_methodIncomingResponse_status(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(ret, 8n), WasmI32.fromGrain(0uS))): Uint16
    }


    @externalName("[method]incoming-response.headers")
    foreign wasm wit_bindgen_methodIncomingResponse_headers: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Returns the headers from the incoming response.
    /// 
    /// The returned `headers` resource is immutable: `set`, `append`, and
    /// `delete` operations will fail with `header-error.immutable`.
    /// 
    /// This headers resource is a child: it must be dropped before the parent
    /// `incoming-response` is dropped.
    @unsafe
    provide let headers: (IncomingResponse) -> Headers = (self) => {
      let ret = wit_bindgen_methodIncomingResponse_headers(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Headers
      handle_lift
    }


    @externalName("[method]incoming-response.consume")
    foreign wasm wit_bindgen_methodIncomingResponse_consume: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the incoming body. May be called at most once. Returns error
    /// if called additional times.
    @unsafe
    provide let consume: (IncomingResponse) -> Result<IncomingBody, Void> = (self) => {
      wit_bindgen_methodIncomingResponse_consume(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: IncomingBody

          Ok(handle_lift)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }

  provide module IncomingBody {
    @externalName("[method]incoming-body.stream")
    foreign wasm wit_bindgen_methodIncomingBody_stream: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the contents of the body, as a stream of bytes.
    /// 
    /// Returns success on first call: the stream representing the contents
    /// can be retrieved at most once. Subsequent calls will return error.
    /// 
    /// The returned `input-stream` resource is a child: it must be dropped
    /// before the parent `incoming-body` is dropped, or consumed by
    /// `incoming-body.finish`.
    /// 
    /// This invariant ensures that the implementation can determine whether
    /// the user is consuming the contents of the body, waiting on the
    /// `future-trailers` to be ready, or neither. This allows for network
    /// backpressure is to be applied when the user is consuming the body,
    /// and for that backpressure to not inhibit delivery of the trailers if
    /// the user does not read the entire body.
    @unsafe
    provide let stream: (IncomingBody) -> Result<InputStream, Void> = (self) => {
      wit_bindgen_methodIncomingBody_stream(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: InputStream

          Ok(handle_lift)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[static]incoming-body.finish")
    foreign wasm wit_bindgen_staticIncomingBody_finish: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Takes ownership of `incoming-body`, and returns a `future-trailers`.
    /// This function will trap if the `input-stream` child is still alive.
    @unsafe
    provide let finish: (IncomingBody) -> FutureTrailers = (this) => {
      let ret = wit_bindgen_staticIncomingBody_finish(WasmI32.load(WasmI32.fromGrain(this.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: FutureTrailers
      handle_lift
    }

  }

  provide module FutureTrailers {
    @externalName("[method]future-trailers.subscribe")
    foreign wasm wit_bindgen_methodFutureTrailers_subscribe: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Returns a pollable which becomes ready when either the trailers have
    /// been received, or an error has occured. When this pollable is ready,
    /// the `get` method will return `some`.
    @unsafe
    provide let subscribe: (FutureTrailers) -> Pollable = (self) => {
      let ret = wit_bindgen_methodFutureTrailers_subscribe(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Pollable
      handle_lift
    }


    @externalName("[method]future-trailers.get")
    foreign wasm wit_bindgen_methodFutureTrailers_get: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the contents of the trailers, or an error which occured,
    /// once the future is ready.
    /// 
    /// The outer `option` represents future readiness. Users can wait on this
    /// `option` to become `some` using the `subscribe` method.
    /// 
    /// The outer `result` is used to retrieve the trailers or error at most
    /// once. It will be success on the first call in which the outer option
    /// is `some`, and error on subsequent calls.
    /// 
    /// The inner `result` represents that either the HTTP Request or Response
    /// body, as well as any trailers, were received successfully, or that an
    /// error occured receiving them. The optional `trailers` indicates whether
    /// or not trailers were present in the body.
    /// 
    /// When some `trailers` are returned by this method, the `trailers`
    /// resource is immutable, and a child. Use of the `set`, `append`, or
    /// `delete` methods will return an error, and the resource must be
    /// dropped before the parent `future-trailers` is dropped.
    @unsafe
    provide let get: (FutureTrailers) -> Option<Result<Result<Option<Trailers>, ErrorCode>, Void>> = (self) => {
      wit_bindgen_methodFutureTrailers_get(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          
          Some(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              
              Ok(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => {
                  
                  Ok(match (WasmI32.load8U(_RET_AREA, 24n)) {
                    0n => None,
                    1n => {
                      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 28n))),}: Trailers

                      Some(handle_lift)
                    },
                    _ => fail "invalid enum discriminant",
                  })
                },
                1n => {
                  
                  Err(match (WasmI32.load8U(_RET_AREA, 24n)) {
                    0n => {
                      DnsTimeout
                    },
                    1n => {
                      DnsError({ rcode: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift = DataStructures.allocateString(len_string_lift)
                          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift)
                          let str_string_lift = WasmI32.toGrain(str_string_lift): String

                          Some(str_string_lift)
                        },
                        _ => fail "invalid enum discriminant",
                      }, infoCode: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load16U(_RET_AREA, 46n), 8n), WasmI32.fromGrain(0uS))): Uint16)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    2n => {
                      DestinationNotFound
                    },
                    3n => {
                      DestinationUnavailable
                    },
                    4n => {
                      DestinationIpProhibited
                    },
                    5n => {
                      DestinationIpUnroutable
                    },
                    6n => {
                      ConnectionRefused
                    },
                    7n => {
                      ConnectionTerminated
                    },
                    8n => {
                      ConnectionTimeout
                    },
                    9n => {
                      ConnectionReadTimeout
                    },
                    10n => {
                      ConnectionWriteTimeout
                    },
                    11n => {
                      ConnectionLimitReached
                    },
                    12n => {
                      TlsProtocolError
                    },
                    13n => {
                      TlsCertificateError
                    },
                    14n => {
                      TlsAlertReceived({ alertId: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load8U(_RET_AREA, 33n), 8n), WasmI32.fromGrain(0us))): Uint8)
                        },
                        _ => fail "invalid enum discriminant",
                      }, alertMessage: match (WasmI32.load8U(_RET_AREA, 36n)) {
                        0n => None,
                        1n => {
                          let len_string_lift0 = WasmI32.load(_RET_AREA, 44n)
                          let str_string_lift0 = DataStructures.allocateString(len_string_lift0)
                          Memory.copy(WasmI32.(+)(str_string_lift0, 8n), WasmI32.load(_RET_AREA, 40n), len_string_lift0)
                          let str_string_lift0 = WasmI32.toGrain(str_string_lift0): String

                          Some(str_string_lift0)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    15n => {
                      HttpRequestDenied
                    },
                    16n => {
                      HttpRequestLengthRequired
                    },
                    17n => {
                      HttpRequestBodySize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 40n))): Uint64)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    18n => {
                      HttpRequestMethodInvalid
                    },
                    19n => {
                      HttpRequestUriInvalid
                    },
                    20n => {
                      HttpRequestUriTooLong
                    },
                    21n => {
                      HttpRequestHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    22n => {
                      HttpRequestHeaderSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some({ fieldName: match (WasmI32.load8U(_RET_AREA, 36n)) {
                            0n => None,
                            1n => {
                              let len_string_lift1 = WasmI32.load(_RET_AREA, 44n)
                              let str_string_lift1 = DataStructures.allocateString(len_string_lift1)
                              Memory.copy(WasmI32.(+)(str_string_lift1, 8n), WasmI32.load(_RET_AREA, 40n), len_string_lift1)
                              let str_string_lift1 = WasmI32.toGrain(str_string_lift1): String

                              Some(str_string_lift1)
                            },
                            _ => fail "invalid enum discriminant",
                          }, fieldSize: match (WasmI32.load8U(_RET_AREA, 48n)) {
                            0n => None,
                            1n => {
                              
                              Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 52n))): Uint32)
                            },
                            _ => fail "invalid enum discriminant",
                          } })
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    23n => {
                      HttpRequestTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    24n => {
                      HttpRequestTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift2 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift2 = DataStructures.allocateString(len_string_lift2)
                          Memory.copy(WasmI32.(+)(str_string_lift2, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift2)
                          let str_string_lift2 = WasmI32.toGrain(str_string_lift2): String

                          Some(str_string_lift2)
                        },
                        _ => fail "invalid enum discriminant",
                      }, fieldSize: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 48n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    25n => {
                      HttpResponseIncomplete
                    },
                    26n => {
                      HttpResponseHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    27n => {
                      HttpResponseHeaderSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift3 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift3 = DataStructures.allocateString(len_string_lift3)
                          Memory.copy(WasmI32.(+)(str_string_lift3, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift3)
                          let str_string_lift3 = WasmI32.toGrain(str_string_lift3): String

                          Some(str_string_lift3)
                        },
                        _ => fail "invalid enum discriminant",
                      }, fieldSize: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 48n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    28n => {
                      HttpResponseBodySize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 40n))): Uint64)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    29n => {
                      HttpResponseTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    30n => {
                      HttpResponseTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift4 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift4 = DataStructures.allocateString(len_string_lift4)
                          Memory.copy(WasmI32.(+)(str_string_lift4, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift4)
                          let str_string_lift4 = WasmI32.toGrain(str_string_lift4): String

                          Some(str_string_lift4)
                        },
                        _ => fail "invalid enum discriminant",
                      }, fieldSize: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 48n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    31n => {
                      HttpResponseTransferCoding(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift5 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift5 = DataStructures.allocateString(len_string_lift5)
                          Memory.copy(WasmI32.(+)(str_string_lift5, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift5)
                          let str_string_lift5 = WasmI32.toGrain(str_string_lift5): String

                          Some(str_string_lift5)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    32n => {
                      HttpResponseContentCoding(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift6 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift6 = DataStructures.allocateString(len_string_lift6)
                          Memory.copy(WasmI32.(+)(str_string_lift6, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift6)
                          let str_string_lift6 = WasmI32.toGrain(str_string_lift6): String

                          Some(str_string_lift6)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    33n => {
                      HttpResponseTimeout
                    },
                    34n => {
                      HttpUpgradeFailed
                    },
                    35n => {
                      HttpProtocolError
                    },
                    36n => {
                      LoopDetected
                    },
                    37n => {
                      ConfigurationError
                    },
                    _ => {
                      InternalError(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift7 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift7 = DataStructures.allocateString(len_string_lift7)
                          Memory.copy(WasmI32.(+)(str_string_lift7, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift7)
                          let str_string_lift7 = WasmI32.toGrain(str_string_lift7): String

                          Some(str_string_lift7)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                  })
                },
                _ => fail "invalid enum discriminant",
              })
            },
            1n => {
              
              Err(void)
            },
            _ => fail "invalid enum discriminant",
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }

  provide module OutgoingResponse {
    @externalName("[constructor]outgoing-response")
    foreign wasm wit_bindgen_constructorOutgoingResponse: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Construct an `outgoing-response`, with a default `status-code` of `200`.
    /// If a different `status-code` is needed, it must be set via the
    /// `set-status-code` method.
    /// 
    /// * `headers` is the HTTP Headers for the Response.
    @unsafe
    provide let constructor: (Headers) -> OutgoingResponse = (headers) => {
      let ret = wit_bindgen_constructorOutgoingResponse(WasmI32.load(WasmI32.fromGrain(headers.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: OutgoingResponse
      handle_lift
    }


    @externalName("[method]outgoing-response.status-code")
    foreign wasm wit_bindgen_methodOutgoingResponse_statusCode: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Get the HTTP Status Code for the Response.
    @unsafe
    provide let statusCode: (OutgoingResponse) -> StatusCode = (self) => {
      let ret = wit_bindgen_methodOutgoingResponse_statusCode(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(ret, 8n), WasmI32.fromGrain(0uS))): Uint16
    }


    @externalName("[method]outgoing-response.set-status-code")
    foreign wasm wit_bindgen_methodOutgoingResponse_setStatusCode: (WasmI32, WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Set the HTTP Status Code for the Response. Fails if the status-code
    /// given is not a valid http status code.
    @unsafe
    provide let setStatusCode: (OutgoingResponse, StatusCode) -> Result<Void, Void> = (self, statusCode) => {
      let ret = wit_bindgen_methodOutgoingResponse_setStatusCode(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), WasmI32.(>>>)(WasmI32.fromGrain(statusCode), 8n))
      match (ret) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[method]outgoing-response.headers")
    foreign wasm wit_bindgen_methodOutgoingResponse_headers: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Get the headers associated with the Request.
    /// 
    /// The returned `headers` resource is immutable: `set`, `append`, and
    /// `delete` operations will fail with `header-error.immutable`.
    /// 
    /// This headers resource is a child: it must be dropped before the parent
    /// `outgoing-request` is dropped, or its ownership is transfered to
    /// another component by e.g. `outgoing-handler.handle`.
    @unsafe
    provide let headers: (OutgoingResponse) -> Headers = (self) => {
      let ret = wit_bindgen_methodOutgoingResponse_headers(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Headers
      handle_lift
    }


    @externalName("[method]outgoing-response.body")
    foreign wasm wit_bindgen_methodOutgoingResponse_body: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the resource corresponding to the outgoing Body for this Response.
    /// 
    /// Returns success on the first call: the `outgoing-body` resource for
    /// this `outgoing-response` can be retrieved at most once. Subsequent
    /// calls will return error.
    @unsafe
    provide let body: (OutgoingResponse) -> Result<OutgoingBody, Void> = (self) => {
      wit_bindgen_methodOutgoingResponse_body(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: OutgoingBody

          Ok(handle_lift)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }

  provide module OutgoingBody {
    @externalName("[method]outgoing-body.write")
    foreign wasm wit_bindgen_methodOutgoingBody_write: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns a stream for writing the body contents.
    /// 
    /// The returned `output-stream` is a child resource: it must be dropped
    /// before the parent `outgoing-body` resource is dropped (or finished),
    /// otherwise the `outgoing-body` drop or `finish` will trap.
    /// 
    /// Returns success on the first call: the `output-stream` resource for
    /// this `outgoing-body` may be retrieved at most once. Subsequent calls
    /// will return error.
    @unsafe
    provide let write: (OutgoingBody) -> Result<OutputStream, Void> = (self) => {
      wit_bindgen_methodOutgoingBody_write(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 4n))),}: OutputStream

          Ok(handle_lift)
        },
        1n => {
          
          Err(void)
        },
        _ => fail "invalid enum discriminant",
      }
    }


    @externalName("[static]outgoing-body.finish")
    foreign wasm wit_bindgen_staticOutgoingBody_finish: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Finalize an outgoing body, optionally providing trailers. This must be
    /// called to signal that the response is complete. If the `outgoing-body`
    /// is dropped without calling `outgoing-body.finalize`, the implementation
    /// should treat the body as corrupted.
    /// 
    /// Fails if the body's `outgoing-request` or `outgoing-response` was
    /// constructed with a Content-Length header, and the contents written
    /// to the body (via `write`) does not match the value given in the
    /// Content-Length.
    @unsafe
    provide let finish: (OutgoingBody, Option<Trailers>) -> Result<Void, ErrorCode> = (this, trailers) => {
      let mut resultoption_lower_0 = 0n
      let mut resultoption_lower_1 = 0n
      match (trailers) {
        Some(e) => {
          resultoption_lower_0 = 1n
          resultoption_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
        },
        None => {
          resultoption_lower_0 = 0n
          resultoption_lower_1 = 0n
        },
      }
      wit_bindgen_staticOutgoingBody_finish(WasmI32.load(WasmI32.fromGrain(this.handle), 4n), resultoption_lower_0, resultoption_lower_1, _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => {
          
          Ok(void)
        },
        1n => {
          
          Err(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              DnsTimeout
            },
            1n => {
              DnsError({ rcode: match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  let len_string_lift = WasmI32.load(_RET_AREA, 24n)
                  let str_string_lift = DataStructures.allocateString(len_string_lift)
                  Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift)
                  let str_string_lift = WasmI32.toGrain(str_string_lift): String

                  Some(str_string_lift)
                },
                _ => fail "invalid enum discriminant",
              }, infoCode: match (WasmI32.load8U(_RET_AREA, 28n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load16U(_RET_AREA, 30n), 8n), WasmI32.fromGrain(0uS))): Uint16)
                },
                _ => fail "invalid enum discriminant",
              } })
            },
            2n => {
              DestinationNotFound
            },
            3n => {
              DestinationUnavailable
            },
            4n => {
              DestinationIpProhibited
            },
            5n => {
              DestinationIpUnroutable
            },
            6n => {
              ConnectionRefused
            },
            7n => {
              ConnectionTerminated
            },
            8n => {
              ConnectionTimeout
            },
            9n => {
              ConnectionReadTimeout
            },
            10n => {
              ConnectionWriteTimeout
            },
            11n => {
              ConnectionLimitReached
            },
            12n => {
              TlsProtocolError
            },
            13n => {
              TlsCertificateError
            },
            14n => {
              TlsAlertReceived({ alertId: match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load8U(_RET_AREA, 17n), 8n), WasmI32.fromGrain(0us))): Uint8)
                },
                _ => fail "invalid enum discriminant",
              }, alertMessage: match (WasmI32.load8U(_RET_AREA, 20n)) {
                0n => None,
                1n => {
                  let len_string_lift0 = WasmI32.load(_RET_AREA, 28n)
                  let str_string_lift0 = DataStructures.allocateString(len_string_lift0)
                  Memory.copy(WasmI32.(+)(str_string_lift0, 8n), WasmI32.load(_RET_AREA, 24n), len_string_lift0)
                  let str_string_lift0 = WasmI32.toGrain(str_string_lift0): String

                  Some(str_string_lift0)
                },
                _ => fail "invalid enum discriminant",
              } })
            },
            15n => {
              HttpRequestDenied
            },
            16n => {
              HttpRequestLengthRequired
            },
            17n => {
              HttpRequestBodySize(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 24n))): Uint64)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            18n => {
              HttpRequestMethodInvalid
            },
            19n => {
              HttpRequestUriInvalid
            },
            20n => {
              HttpRequestUriTooLong
            },
            21n => {
              HttpRequestHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            22n => {
              HttpRequestHeaderSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some({ fieldName: match (WasmI32.load8U(_RET_AREA, 20n)) {
                    0n => None,
                    1n => {
                      let len_string_lift1 = WasmI32.load(_RET_AREA, 28n)
                      let str_string_lift1 = DataStructures.allocateString(len_string_lift1)
                      Memory.copy(WasmI32.(+)(str_string_lift1, 8n), WasmI32.load(_RET_AREA, 24n), len_string_lift1)
                      let str_string_lift1 = WasmI32.toGrain(str_string_lift1): String

                      Some(str_string_lift1)
                    },
                    _ => fail "invalid enum discriminant",
                  }, fieldSize: match (WasmI32.load8U(_RET_AREA, 32n)) {
                    0n => None,
                    1n => {
                      
                      Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                    },
                    _ => fail "invalid enum discriminant",
                  } })
                },
                _ => fail "invalid enum discriminant",
              })
            },
            23n => {
              HttpRequestTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            24n => {
              HttpRequestTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  let len_string_lift2 = WasmI32.load(_RET_AREA, 24n)
                  let str_string_lift2 = DataStructures.allocateString(len_string_lift2)
                  Memory.copy(WasmI32.(+)(str_string_lift2, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift2)
                  let str_string_lift2 = WasmI32.toGrain(str_string_lift2): String

                  Some(str_string_lift2)
                },
                _ => fail "invalid enum discriminant",
              }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
                },
                _ => fail "invalid enum discriminant",
              } })
            },
            25n => {
              HttpResponseIncomplete
            },
            26n => {
              HttpResponseHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            27n => {
              HttpResponseHeaderSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  let len_string_lift3 = WasmI32.load(_RET_AREA, 24n)
                  let str_string_lift3 = DataStructures.allocateString(len_string_lift3)
                  Memory.copy(WasmI32.(+)(str_string_lift3, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift3)
                  let str_string_lift3 = WasmI32.toGrain(str_string_lift3): String

                  Some(str_string_lift3)
                },
                _ => fail "invalid enum discriminant",
              }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
                },
                _ => fail "invalid enum discriminant",
              } })
            },
            28n => {
              HttpResponseBodySize(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 24n))): Uint64)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            29n => {
              HttpResponseTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            30n => {
              HttpResponseTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  let len_string_lift4 = WasmI32.load(_RET_AREA, 24n)
                  let str_string_lift4 = DataStructures.allocateString(len_string_lift4)
                  Memory.copy(WasmI32.(+)(str_string_lift4, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift4)
                  let str_string_lift4 = WasmI32.toGrain(str_string_lift4): String

                  Some(str_string_lift4)
                },
                _ => fail "invalid enum discriminant",
              }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
                0n => None,
                1n => {
                  
                  Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
                },
                _ => fail "invalid enum discriminant",
              } })
            },
            31n => {
              HttpResponseTransferCoding(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  let len_string_lift5 = WasmI32.load(_RET_AREA, 24n)
                  let str_string_lift5 = DataStructures.allocateString(len_string_lift5)
                  Memory.copy(WasmI32.(+)(str_string_lift5, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift5)
                  let str_string_lift5 = WasmI32.toGrain(str_string_lift5): String

                  Some(str_string_lift5)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            32n => {
              HttpResponseContentCoding(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  let len_string_lift6 = WasmI32.load(_RET_AREA, 24n)
                  let str_string_lift6 = DataStructures.allocateString(len_string_lift6)
                  Memory.copy(WasmI32.(+)(str_string_lift6, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift6)
                  let str_string_lift6 = WasmI32.toGrain(str_string_lift6): String

                  Some(str_string_lift6)
                },
                _ => fail "invalid enum discriminant",
              })
            },
            33n => {
              HttpResponseTimeout
            },
            34n => {
              HttpUpgradeFailed
            },
            35n => {
              HttpProtocolError
            },
            36n => {
              LoopDetected
            },
            37n => {
              ConfigurationError
            },
            _ => {
              InternalError(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => None,
                1n => {
                  let len_string_lift7 = WasmI32.load(_RET_AREA, 24n)
                  let str_string_lift7 = DataStructures.allocateString(len_string_lift7)
                  Memory.copy(WasmI32.(+)(str_string_lift7, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift7)
                  let str_string_lift7 = WasmI32.toGrain(str_string_lift7): String

                  Some(str_string_lift7)
                },
                _ => fail "invalid enum discriminant",
              })
            },
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }

  provide module FutureIncomingResponse {
    @externalName("[method]future-incoming-response.subscribe")
    foreign wasm wit_bindgen_methodFutureIncomingResponse_subscribe: (WasmI32) -> WasmI32 from "wasi:http/types@0.2.0"

    /// Returns a pollable which becomes ready when either the Response has
    /// been received, or an error has occured. When this pollable is ready,
    /// the `get` method will return `some`.
    @unsafe
    provide let subscribe: (FutureIncomingResponse) -> Pollable = (self) => {
      let ret = wit_bindgen_methodFutureIncomingResponse_subscribe(WasmI32.load(WasmI32.fromGrain(self.handle), 4n))
      let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(ret)),}: Pollable
      handle_lift
    }


    @externalName("[method]future-incoming-response.get")
    foreign wasm wit_bindgen_methodFutureIncomingResponse_get: (WasmI32, WasmI32) -> Void from "wasi:http/types@0.2.0"

    /// Returns the incoming HTTP Response, or an error, once one is ready.
    /// 
    /// The outer `option` represents future readiness. Users can wait on this
    /// `option` to become `some` using the `subscribe` method.
    /// 
    /// The outer `result` is used to retrieve the response or error at most
    /// once. It will be success on the first call in which the outer option
    /// is `some`, and error on subsequent calls.
    /// 
    /// The inner `result` represents that either the incoming HTTP Response
    /// status and headers have recieved successfully, or that an error
    /// occured. Errors may also occur while consuming the response body,
    /// but those will be reported by the `incoming-body` and its
    /// `output-stream` child.
    @unsafe
    provide let get: (FutureIncomingResponse) -> Option<Result<Result<IncomingResponse, ErrorCode>, Void>> = (self) => {
      wit_bindgen_methodFutureIncomingResponse_get(WasmI32.load(WasmI32.fromGrain(self.handle), 4n), _RET_AREA)
      match (WasmI32.load8U(_RET_AREA, 0n)) {
        0n => None,
        1n => {
          
          Some(match (WasmI32.load8U(_RET_AREA, 8n)) {
            0n => {
              
              Ok(match (WasmI32.load8U(_RET_AREA, 16n)) {
                0n => {
                  let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 24n))),}: IncomingResponse

                  Ok(handle_lift)
                },
                1n => {
                  
                  Err(match (WasmI32.load8U(_RET_AREA, 24n)) {
                    0n => {
                      DnsTimeout
                    },
                    1n => {
                      DnsError({ rcode: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift = DataStructures.allocateString(len_string_lift)
                          Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift)
                          let str_string_lift = WasmI32.toGrain(str_string_lift): String

                          Some(str_string_lift)
                        },
                        _ => fail "invalid enum discriminant",
                      }, infoCode: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load16U(_RET_AREA, 46n), 8n), WasmI32.fromGrain(0uS))): Uint16)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    2n => {
                      DestinationNotFound
                    },
                    3n => {
                      DestinationUnavailable
                    },
                    4n => {
                      DestinationIpProhibited
                    },
                    5n => {
                      DestinationIpUnroutable
                    },
                    6n => {
                      ConnectionRefused
                    },
                    7n => {
                      ConnectionTerminated
                    },
                    8n => {
                      ConnectionTimeout
                    },
                    9n => {
                      ConnectionReadTimeout
                    },
                    10n => {
                      ConnectionWriteTimeout
                    },
                    11n => {
                      ConnectionLimitReached
                    },
                    12n => {
                      TlsProtocolError
                    },
                    13n => {
                      TlsCertificateError
                    },
                    14n => {
                      TlsAlertReceived({ alertId: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load8U(_RET_AREA, 33n), 8n), WasmI32.fromGrain(0us))): Uint8)
                        },
                        _ => fail "invalid enum discriminant",
                      }, alertMessage: match (WasmI32.load8U(_RET_AREA, 36n)) {
                        0n => None,
                        1n => {
                          let len_string_lift0 = WasmI32.load(_RET_AREA, 44n)
                          let str_string_lift0 = DataStructures.allocateString(len_string_lift0)
                          Memory.copy(WasmI32.(+)(str_string_lift0, 8n), WasmI32.load(_RET_AREA, 40n), len_string_lift0)
                          let str_string_lift0 = WasmI32.toGrain(str_string_lift0): String

                          Some(str_string_lift0)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    15n => {
                      HttpRequestDenied
                    },
                    16n => {
                      HttpRequestLengthRequired
                    },
                    17n => {
                      HttpRequestBodySize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 40n))): Uint64)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    18n => {
                      HttpRequestMethodInvalid
                    },
                    19n => {
                      HttpRequestUriInvalid
                    },
                    20n => {
                      HttpRequestUriTooLong
                    },
                    21n => {
                      HttpRequestHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    22n => {
                      HttpRequestHeaderSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some({ fieldName: match (WasmI32.load8U(_RET_AREA, 36n)) {
                            0n => None,
                            1n => {
                              let len_string_lift1 = WasmI32.load(_RET_AREA, 44n)
                              let str_string_lift1 = DataStructures.allocateString(len_string_lift1)
                              Memory.copy(WasmI32.(+)(str_string_lift1, 8n), WasmI32.load(_RET_AREA, 40n), len_string_lift1)
                              let str_string_lift1 = WasmI32.toGrain(str_string_lift1): String

                              Some(str_string_lift1)
                            },
                            _ => fail "invalid enum discriminant",
                          }, fieldSize: match (WasmI32.load8U(_RET_AREA, 48n)) {
                            0n => None,
                            1n => {
                              
                              Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 52n))): Uint32)
                            },
                            _ => fail "invalid enum discriminant",
                          } })
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    23n => {
                      HttpRequestTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    24n => {
                      HttpRequestTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift2 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift2 = DataStructures.allocateString(len_string_lift2)
                          Memory.copy(WasmI32.(+)(str_string_lift2, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift2)
                          let str_string_lift2 = WasmI32.toGrain(str_string_lift2): String

                          Some(str_string_lift2)
                        },
                        _ => fail "invalid enum discriminant",
                      }, fieldSize: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 48n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    25n => {
                      HttpResponseIncomplete
                    },
                    26n => {
                      HttpResponseHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    27n => {
                      HttpResponseHeaderSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift3 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift3 = DataStructures.allocateString(len_string_lift3)
                          Memory.copy(WasmI32.(+)(str_string_lift3, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift3)
                          let str_string_lift3 = WasmI32.toGrain(str_string_lift3): String

                          Some(str_string_lift3)
                        },
                        _ => fail "invalid enum discriminant",
                      }, fieldSize: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 48n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    28n => {
                      HttpResponseBodySize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 40n))): Uint64)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    29n => {
                      HttpResponseTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    30n => {
                      HttpResponseTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift4 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift4 = DataStructures.allocateString(len_string_lift4)
                          Memory.copy(WasmI32.(+)(str_string_lift4, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift4)
                          let str_string_lift4 = WasmI32.toGrain(str_string_lift4): String

                          Some(str_string_lift4)
                        },
                        _ => fail "invalid enum discriminant",
                      }, fieldSize: match (WasmI32.load8U(_RET_AREA, 44n)) {
                        0n => None,
                        1n => {
                          
                          Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 48n))): Uint32)
                        },
                        _ => fail "invalid enum discriminant",
                      } })
                    },
                    31n => {
                      HttpResponseTransferCoding(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift5 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift5 = DataStructures.allocateString(len_string_lift5)
                          Memory.copy(WasmI32.(+)(str_string_lift5, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift5)
                          let str_string_lift5 = WasmI32.toGrain(str_string_lift5): String

                          Some(str_string_lift5)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    32n => {
                      HttpResponseContentCoding(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift6 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift6 = DataStructures.allocateString(len_string_lift6)
                          Memory.copy(WasmI32.(+)(str_string_lift6, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift6)
                          let str_string_lift6 = WasmI32.toGrain(str_string_lift6): String

                          Some(str_string_lift6)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                    33n => {
                      HttpResponseTimeout
                    },
                    34n => {
                      HttpUpgradeFailed
                    },
                    35n => {
                      HttpProtocolError
                    },
                    36n => {
                      LoopDetected
                    },
                    37n => {
                      ConfigurationError
                    },
                    _ => {
                      InternalError(match (WasmI32.load8U(_RET_AREA, 32n)) {
                        0n => None,
                        1n => {
                          let len_string_lift7 = WasmI32.load(_RET_AREA, 40n)
                          let str_string_lift7 = DataStructures.allocateString(len_string_lift7)
                          Memory.copy(WasmI32.(+)(str_string_lift7, 8n), WasmI32.load(_RET_AREA, 36n), len_string_lift7)
                          let str_string_lift7 = WasmI32.toGrain(str_string_lift7): String

                          Some(str_string_lift7)
                        },
                        _ => fail "invalid enum discriminant",
                      })
                    },
                  })
                },
                _ => fail "invalid enum discriminant",
              })
            },
            1n => {
              
              Err(void)
            },
            _ => fail "invalid enum discriminant",
          })
        },
        _ => fail "invalid enum discriminant",
      }
    }

  }
}



provide module OutgoingHandler {

  @externalName("handle")
  foreign wasm wit_bindgen_handle: (WasmI32, WasmI32, WasmI32, WasmI32) -> Void from "wasi:http/outgoing-handler@0.2.0"

  /// This function is invoked with an outgoing HTTP Request, and it returns
  /// a resource `future-incoming-response` which represents an HTTP Response
  /// which may arrive in the future.
  /// 
  /// The `options` argument accepts optional parameters for the HTTP
  /// protocol's transport layer.
  /// 
  /// This function may return an error if the `outgoing-request` is invalid
  /// or not allowed to be made. Otherwise, protocol errors are reported
  /// through the `future-incoming-response`.
  @unsafe
  provide let handle: (OutgoingRequest, Option<RequestOptions>) -> Result<FutureIncomingResponse, ErrorCode> = (request, options) => {
    let mut resultoption_lower_0 = 0n
    let mut resultoption_lower_1 = 0n
    match (options) {
      Some(e) => {
        resultoption_lower_0 = 1n
        resultoption_lower_1 = WasmI32.load(WasmI32.fromGrain(e.handle), 4n)
      },
      None => {
        resultoption_lower_0 = 0n
        resultoption_lower_1 = 0n
      },
    }
    wit_bindgen_handle(WasmI32.load(WasmI32.fromGrain(request.handle), 4n), resultoption_lower_0, resultoption_lower_1, _RET_AREA)
    match (WasmI32.load8U(_RET_AREA, 0n)) {
      0n => {
        let handle_lift = {handle: WasmI32.toGrain(DataStructures.newInt32(WasmI32.load(_RET_AREA, 8n))),}: FutureIncomingResponse

        Ok(handle_lift)
      },
      1n => {
        
        Err(match (WasmI32.load8U(_RET_AREA, 8n)) {
          0n => {
            DnsTimeout
          },
          1n => {
            DnsError({ rcode: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift = DataStructures.allocateString(len_string_lift)
                Memory.copy(WasmI32.(+)(str_string_lift, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift)
                let str_string_lift = WasmI32.toGrain(str_string_lift): String

                Some(str_string_lift)
              },
              _ => fail "invalid enum discriminant",
            }, infoCode: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load16U(_RET_AREA, 30n), 8n), WasmI32.fromGrain(0uS))): Uint16)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          2n => {
            DestinationNotFound
          },
          3n => {
            DestinationUnavailable
          },
          4n => {
            DestinationIpProhibited
          },
          5n => {
            DestinationIpUnroutable
          },
          6n => {
            ConnectionRefused
          },
          7n => {
            ConnectionTerminated
          },
          8n => {
            ConnectionTimeout
          },
          9n => {
            ConnectionReadTimeout
          },
          10n => {
            ConnectionWriteTimeout
          },
          11n => {
            ConnectionLimitReached
          },
          12n => {
            TlsProtocolError
          },
          13n => {
            TlsCertificateError
          },
          14n => {
            TlsAlertReceived({ alertId: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(WasmI32.(|)(WasmI32.(<<)(WasmI32.load8U(_RET_AREA, 17n), 8n), WasmI32.fromGrain(0us))): Uint8)
              },
              _ => fail "invalid enum discriminant",
            }, alertMessage: match (WasmI32.load8U(_RET_AREA, 20n)) {
              0n => None,
              1n => {
                let len_string_lift0 = WasmI32.load(_RET_AREA, 28n)
                let str_string_lift0 = DataStructures.allocateString(len_string_lift0)
                Memory.copy(WasmI32.(+)(str_string_lift0, 8n), WasmI32.load(_RET_AREA, 24n), len_string_lift0)
                let str_string_lift0 = WasmI32.toGrain(str_string_lift0): String

                Some(str_string_lift0)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          15n => {
            HttpRequestDenied
          },
          16n => {
            HttpRequestLengthRequired
          },
          17n => {
            HttpRequestBodySize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 24n))): Uint64)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          18n => {
            HttpRequestMethodInvalid
          },
          19n => {
            HttpRequestUriInvalid
          },
          20n => {
            HttpRequestUriTooLong
          },
          21n => {
            HttpRequestHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          22n => {
            HttpRequestHeaderSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some({ fieldName: match (WasmI32.load8U(_RET_AREA, 20n)) {
                  0n => None,
                  1n => {
                    let len_string_lift1 = WasmI32.load(_RET_AREA, 28n)
                    let str_string_lift1 = DataStructures.allocateString(len_string_lift1)
                    Memory.copy(WasmI32.(+)(str_string_lift1, 8n), WasmI32.load(_RET_AREA, 24n), len_string_lift1)
                    let str_string_lift1 = WasmI32.toGrain(str_string_lift1): String

                    Some(str_string_lift1)
                  },
                  _ => fail "invalid enum discriminant",
                }, fieldSize: match (WasmI32.load8U(_RET_AREA, 32n)) {
                  0n => None,
                  1n => {
                    
                    Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 36n))): Uint32)
                  },
                  _ => fail "invalid enum discriminant",
                } })
              },
              _ => fail "invalid enum discriminant",
            })
          },
          23n => {
            HttpRequestTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          24n => {
            HttpRequestTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift2 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift2 = DataStructures.allocateString(len_string_lift2)
                Memory.copy(WasmI32.(+)(str_string_lift2, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift2)
                let str_string_lift2 = WasmI32.toGrain(str_string_lift2): String

                Some(str_string_lift2)
              },
              _ => fail "invalid enum discriminant",
            }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          25n => {
            HttpResponseIncomplete
          },
          26n => {
            HttpResponseHeaderSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          27n => {
            HttpResponseHeaderSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift3 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift3 = DataStructures.allocateString(len_string_lift3)
                Memory.copy(WasmI32.(+)(str_string_lift3, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift3)
                let str_string_lift3 = WasmI32.toGrain(str_string_lift3): String

                Some(str_string_lift3)
              },
              _ => fail "invalid enum discriminant",
            }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          28n => {
            HttpResponseBodySize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 24n))): Uint64)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          29n => {
            HttpResponseTrailerSectionSize(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 20n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          30n => {
            HttpResponseTrailerSize({ fieldName: match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift4 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift4 = DataStructures.allocateString(len_string_lift4)
                Memory.copy(WasmI32.(+)(str_string_lift4, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift4)
                let str_string_lift4 = WasmI32.toGrain(str_string_lift4): String

                Some(str_string_lift4)
              },
              _ => fail "invalid enum discriminant",
            }, fieldSize: match (WasmI32.load8U(_RET_AREA, 28n)) {
              0n => None,
              1n => {
                
                Some(WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 32n))): Uint32)
              },
              _ => fail "invalid enum discriminant",
            } })
          },
          31n => {
            HttpResponseTransferCoding(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift5 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift5 = DataStructures.allocateString(len_string_lift5)
                Memory.copy(WasmI32.(+)(str_string_lift5, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift5)
                let str_string_lift5 = WasmI32.toGrain(str_string_lift5): String

                Some(str_string_lift5)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          32n => {
            HttpResponseContentCoding(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift6 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift6 = DataStructures.allocateString(len_string_lift6)
                Memory.copy(WasmI32.(+)(str_string_lift6, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift6)
                let str_string_lift6 = WasmI32.toGrain(str_string_lift6): String

                Some(str_string_lift6)
              },
              _ => fail "invalid enum discriminant",
            })
          },
          33n => {
            HttpResponseTimeout
          },
          34n => {
            HttpUpgradeFailed
          },
          35n => {
            HttpProtocolError
          },
          36n => {
            LoopDetected
          },
          37n => {
            ConfigurationError
          },
          _ => {
            InternalError(match (WasmI32.load8U(_RET_AREA, 16n)) {
              0n => None,
              1n => {
                let len_string_lift7 = WasmI32.load(_RET_AREA, 24n)
                let str_string_lift7 = DataStructures.allocateString(len_string_lift7)
                Memory.copy(WasmI32.(+)(str_string_lift7, 8n), WasmI32.load(_RET_AREA, 20n), len_string_lift7)
                let str_string_lift7 = WasmI32.toGrain(str_string_lift7): String

                Some(str_string_lift7)
              },
              _ => fail "invalid enum discriminant",
            })
          },
        })
      },
      _ => fail "invalid enum discriminant",
    }
  }

}

provide record Datetime {
  seconds: Uint64,
  nanoseconds: Uint32,
}


provide module WallClock {

  @externalName("now")
  foreign wasm wit_bindgen_now: (WasmI32) -> Void from "wasi:clocks/wall-clock@0.2.0"

  /// Read the current value of the clock.
  /// 
  /// This clock is not monotonic, therefore calling this function repeatedly
  /// will not necessarily produce a sequence of non-decreasing values.
  /// 
  /// The returned timestamps represent the number of seconds since
  /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
  /// also known as [Unix Time].
  /// 
  /// The nanoseconds field of the output is always less than 1000000000.
  /// 
  /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
  /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
  @unsafe
  provide let now: () -> Datetime = () => {
    wit_bindgen_now(_RET_AREA)
    { seconds: WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 0n))): Uint64, nanoseconds: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 8n))): Uint32 }
  }


  @externalName("resolution")
  foreign wasm wit_bindgen_resolution: (WasmI32) -> Void from "wasi:clocks/wall-clock@0.2.0"

  /// Query the resolution of the clock.
  /// 
  /// The nanoseconds field of the output is always less than 1000000000.
  @unsafe
  provide let resolution: () -> Datetime = () => {
    wit_bindgen_resolution(_RET_AREA)
    { seconds: WasmI32.toGrain(DataStructures.newUint64(WasmI64.load(_RET_AREA, 0n))): Uint64, nanoseconds: WasmI32.toGrain(DataStructures.newUint32(WasmI32.load(_RET_AREA, 8n))): Uint32 }
  }

}

